<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql笔记</title>
      <link href="/mysql%E7%AC%94%E8%AE%B0/"/>
      <url>/mysql%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="mysql启动停止命令"><a href="#mysql启动停止命令" class="headerlink" title="mysql启动停止命令"></a>mysql启动停止命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动：net start [mysql服务名]</span><br><span class="line">停止：net stop [mysql服务名]</span><br></pre></td></tr></table></figure><h4 id="mysql连接"><a href="#mysql连接" class="headerlink" title="mysql连接"></a>mysql连接</h4><p><code>mysql [-h 127.0.0.1] [-p 3306] -u root -p</code></p><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>可以单行或多行书写，以分号结尾</li><li>可以使用若干空格&#x2F;缩进增强语句的可读性</li><li>mysql数据库的SQL语句不区分大小写，关键字建议使用大写</li><li>单行注释：<code>-- 注释内容</code>或<code># 注释内容</code></li><li>多行注释：<code>/* 注释内容 */</code></li></ul><h3 id="MySQL语言"><a href="#MySQL语言" class="headerlink" title="MySQL语言"></a>MySQL语言</h3><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul><li>DDL（Data Definition Language）：数据定义语言，用于定义数据库对象（数据库、表、字段）</li><li>DML（Data Manipulation Language）：数据操作语言，用于对数据库中的数据进行增删改</li><li>DQL（Data Query Language）：数据查询语言，用于查询数据库表的记录</li><li>DCL（Data Control Language）：数据控制语言，用于创建数据库用户、控制数据库的访问权限</li></ul><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><h5 id="DDL数据库操作"><a href="#DDL数据库操作" class="headerlink" title="DDL数据库操作"></a>DDL数据库操作</h5><h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><ul><li>查询所有数据库：<code>show database;</code></li><li>查询当前数据库：<code>select database();</code></li></ul><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><p><code>create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</code></p><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p><code>drop database [if exists] 数据库名;</code></p><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p><code>use 数据库名</code></p><h5 id="DDL表操作"><a href="#DDL表操作" class="headerlink" title="DDL表操作"></a>DDL表操作</h5><p>MySQL数据类型主要分为3类：数值类型、字符串类型、日期时间类型：</p><table><thead><tr><th>数值类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th></tr></thead><tbody><tr><td>tinyint</td><td>1byte</td><td>(-128,127)</td><td>(0,255)</td></tr><tr><td>smallint</td><td>2byte</td><td>(-32768,32767)</td><td>(0,65535)</td></tr><tr><td>int或integer</td><td>4byte</td><td>(±2147483648)</td><td>(0,4294967295)</td></tr><tr><td>bigint</td><td>8byte</td><td>(-2^63,2^63-1)</td><td>(0,2^64-1)</td></tr><tr><td>float</td><td>4byte</td><td></td><td></td></tr><tr><td>double</td><td>8byte</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>字符串类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>char</td><td>0-255</td><td>定长字符串（性能高）</td></tr><tr><td>varchar</td><td>0-65535</td><td>变长字符串（性能较差）</td></tr><tr><td>tinyblob</td><td>0-255</td><td>不超过255个字节的二进制数据</td></tr><tr><td>tinytext</td><td>0-255</td><td>短文本字符串</td></tr><tr><td>blob</td><td>0-65535</td><td>二进制长文本数据</td></tr><tr><td>text</td><td>0-65535</td><td>长文本数据</td></tr><tr><td>longblob</td><td>0-429467295</td><td>二进制极大文本数据</td></tr><tr><td>longtext</td><td>0-429467295</td><td>极大长文本数据</td></tr></tbody></table><table><thead><tr><th>日期时间类型</th><th>大小</th><th>范围</th><th>格式</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>1000-01-01至9999-12-31</td><td>YYYY-MM-DD</td></tr><tr><td>time</td><td>3</td><td>-838:59:59至838:59:59</td><td>HH:MM:SS</td></tr><tr><td>year</td><td>1</td><td>1901至2155</td><td>YYYY</td></tr><tr><td>datetime</td><td>8</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><h6 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h6><ul><li>查询当前数据库所有表：<code>show tables;</code></li><li>查询表结构：<code>desc 表名;</code></li><li>查询指定表的建表语句：<code>show create table 表名;</code></li></ul><h6 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">        字段1 字段1的类型 [comment &#x27;字段1注释&#x27;]，</span><br><span class="line">        字段2 字段2的类型 [comment &#x27;字段2注释&#x27;]，</span><br><span class="line">        字段3 字段3的类型 [comment &#x27;字段3注释&#x27;]，</span><br><span class="line">        ......</span><br><span class="line">        字段n 字段n的类型 [comment &#x27;字段n注释&#x27;]</span><br><span class="line">)[comment &#x27;表注释&#x27;];</span><br></pre></td></tr></table></figure><h6 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h6><ul><li>添加字段：<code>alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</code></li><li>修改数据类型：<code>alter table 表名 modify 字段名 新数据类型(长度);</code></li><li>修改字段名和字段类型：<code>alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</code></li><li>删除字段：<code>alter table 表名 drop 字段名;</code></li><li>修改表名：<code>alter table 表名 rename to 新表名;</code></li></ul><h6 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h6><ul><li>删除表：<code>drop table [if exists] 表名;</code></li><li>删除指定表，并重新创建该表：<code>truncate table 表名;</code></li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><ul><li>添加指定字段：<code>insert into 表名 (字段名1, ...) values (值1, ...);</code></li><li>添加全部字段：<code>insert into values (值1,...);</code></li><li>批量添加数据：<code>insert into 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></li></ul><p><strong>注：</strong>字符串和日期类型数据应包含在引号中；插入数据大小应在字段的规定范围内</p><h5 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h5><ul><li>修改数据：<code>update 表名 set 字段名1 = 值1, 字段名2 = 值2, ... [where 条件];</code></li><li>删除数据：<code>delete from 表名 [where 条件];</code></li></ul><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名字段</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><ul><li><p>去除重复记录：<code>select distinct 字段列表 from 表名;</code></p></li><li><p>转义：<code>select * from 表名 where name like &#39;/_张三&#39; escape &#39;/&#39;;</code>&#x2F;之后的_不作为通配符</p></li><li><p>条件查询条件列表：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 &amp;#124;&amp;#124;</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table></li><li><p>聚合查询常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table></li><li><p>分组查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">where和having的区别：</span><br><span class="line">执行时机不同：where是分组前过滤，不满足条件的不参与分组；having是分组后对结果进行过滤</span><br><span class="line">判断条件不同：where不能对聚合函数进行判断，而having可以</span><br><span class="line"></span><br><span class="line">执行顺序：where &gt; 聚合函数 &gt; having</span><br><span class="line">分组之后查询字段一般为聚合函数和分组函数，查询其它字段无任何意义</span><br></pre></td></tr></table></figure></li><li><p>排序查询：<code>select 字段列表 from 表名 order by 字段1 排序方式1, 字段2 排序方式2;</code></p><p>ASC：升序、DESC：降序</p><p>若为多字段排序，只有当第一个字段值相同时才会根据第二个字段进行排序</p></li><li><p>分页查询：<code>select 字段列表 from 表名 limit 起始索引, 查询记录数;</code></p><p>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数；</p><p>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT；</p><p>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10；</p></li><li><p>DQL执行顺序：FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p></li></ul><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><p><code>select * from user;</code></p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p><code>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</code></p><h5 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h5><p><code>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></p><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><p><code>drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建用户test，只能在当前主机localhost访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 创建用户test，能在任意主机访问</span><br><span class="line">create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">create user &#x27;test&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 修改密码</span><br><span class="line">alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line">-- 删除用户</span><br><span class="line">drop user &#x27;test&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><ul><li>查询权限：<code>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>撤销权限：<code>revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul><p><strong>注意事项</strong></p><ul><li><p>多个权限用逗号分隔</p></li><li><p>授权时，数据库名和表名可以用*进行通配，代表所有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#授予root用户在所有终端远程登录，密码为123456</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">#对所有数据库和所有表有操作权限with grant option</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;</span><br></pre></td></tr></table></figure></li></ul><h3 id="MySQL函数"><a href="#MySQL函数" class="headerlink" title="MySQL函数"></a>MySQL函数</h3><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td>REPLACE(column, source, replace)</td><td>替换字符串</td></tr></tbody></table><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date,INTERVAL expr type)</td><td>返回一个日期&#x2F;时间加上时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t,f)</td><td>若value为true则返回t，否则返回f</td></tr><tr><td>IFNULL(value1,value2)</td><td>若value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td>若val1为true，返回res1，…否则返回default默认值</td></tr><tr><td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td>若expr值为val1，返回res1，…否则返回default默认值</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">name,(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)</span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证字段所有数据都是唯一的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td></td><td></td><td>AUTO_INCREMENT</td></tr><tr><td>默认约束</td><td>保存数据时，若未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user (</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(10) not null unique,</span><br><span class="line">    age int check(age &gt; 0 and age &lt; 120),</span><br><span class="line">    status char(1) default &#x27;1&#x27;,</span><br><span class="line">    gender char(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加外键</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</span><br><span class="line"></span><br><span class="line"># 删除外键</span><br><span class="line">alter table 表名 drop foreign key 外键名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h4><h5 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例：部门与员工</span><br><span class="line">关系：一个部门对应多个员工，一个员工对应一个部门</span><br><span class="line">实现：在多的一方建立外键，指向一的一方的主键</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例：学生与课程</span><br><span class="line">关系：一个学生可以选多门课程，一门课程可以供多个学生选修</span><br><span class="line">实现：建立中间表，中间表至少包含两个外键，分别关联两方主键</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例：用户与用户详情</span><br><span class="line">关系：一对一关系，多用于单表拆分，基础字段和详情字段分别放在两张表，以提升操作效率</span><br><span class="line">实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h4><h5 id="合并查询（笛卡尔积，展示所有组合结果）"><a href="#合并查询（笛卡尔积，展示所有组合结果）" class="headerlink" title="合并查询（笛卡尔积，展示所有组合结果）"></a>合并查询（笛卡尔积，展示所有组合结果）</h5><blockquote><p>笛卡尔积：两集合所有组合情况（在多表查询时需要消除无效的笛卡尔积）</p></blockquote><p><code>select * from employee,dept;</code></p><ul><li>消除无效笛卡尔积：<code>select * from employee,dept where employee.dept = dept.id;</code></li></ul><h5 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h5><p>内连接查询的是两张表交集的部分；显示内连接比隐式性能更高</p><ul><li>隐式内连接：<code>select 字段列表 from 表1,表2 where 条件 ...;</code></li><li>显示内连接：<code>select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ...;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工姓名及关联部门的名称</span><br><span class="line">-- 隐式</span><br><span class="line">select e.name,d.name from employee as e,dept as d where e.dept = d.id;</span><br><span class="line">-- 显示</span><br><span class="line">select e.name,d.name from employee as e inner join dept as d on e.dept = d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h5><ul><li><p>左外连接：查询左表所有数据和两张表交集数据</p><p><code>select 字段列表 from 表1 left [ outer ] join 表2 on 条件 ...; </code></p></li><li><p>右外连接：查询右表所有数据和两张表交集数据</p><p><code>select 字段列表 from 表1 right [ outer ] join 表2 on 条件 ...;</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 左</span><br><span class="line">select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;</span><br><span class="line">-- 右</span><br><span class="line">select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;</span><br><span class="line"></span><br><span class="line"># 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h5><p>当前表与自身的连接查询，自连接必须使用表别名；自连接查询可以是内连接查询也可以是外连接查询</p><p><code>select 字段列表 from 表A 别名A join 表A 别名B on 条件 ...;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询员工及所属领导的名字</span><br><span class="line">select a.name,b.name from employee a,employee b where a.manager = b.id;</span><br><span class="line">-- 没有领导的也查询出来</span><br><span class="line">select a.name,b.name from employee a left join employee b on a.manager = b.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="联合查询union、union-all"><a href="#联合查询union、union-all" class="headerlink" title="联合查询union、union all"></a>联合查询union、union all</h5><p>将多次查询的结果合并，形成一个新的查询集</p><p><strong>注：</strong>union all会有重复结果，union不会；联合查询比使用or效率高，不会使索引失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表A ...</span><br><span class="line">union [all]</span><br><span class="line">select 字段列表 from 表B ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h5><p>子查询的位置可在<code>where之后</code>、<code>from之后</code>、<code>select之后</code></p><h6 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h6><p>返回的结果是一列（可以是多行）</p><ul><li>常用操作符：in、not in、any、some（等同于any）、all</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询销售部和市场部所有员工信息</span><br><span class="line">select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;)</span><br><span class="line">-- 查询比财务部所有人工资都高的员工信息</span><br><span class="line">select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line">-- 查询比研发部任意一人工资高的员工信息</span><br><span class="line">select * from employee where salary &gt; any(select salary from employ where dept = (select id from dept where name = &#x27;研发部&#x27;))；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h6><p>返回的结果是一行（可以是多列）</p><ul><li>常用操作符：&#x3D;、&lt;、&gt;、in、not in</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx的薪资及直属领导相同的员工信息</span><br><span class="line">select * from employee where (salary,manager) = (12500,1);</span><br><span class="line">select * from employee where (salary,manager) = (select salary,manager from employee where name = &#x27;xxx&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h6><p>返回的结果是多行多列</p><ul><li>常用操作符：in</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询与xxx1、xxx2的职位和薪资相同的员工</span><br><span class="line">select * from employee where (job,salary) in (select job,salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);</span><br><span class="line">-- 查询入职日期是2006-01-01之后的员工及部门信息</span><br><span class="line">select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一组操作的集合，事务将所有操作作为一个整体一起向系统提交或撤销操作请求；即这些操作要么同时成功，要么同时失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 一、</span><br><span class="line">-- 查看事务提交方式</span><br><span class="line">select @@AUTOCOMMIT;</span><br><span class="line">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span><br><span class="line">set @@AUTOCOMMIT = 0;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line">-- 回滚事务</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">-- 事务实例（设置手动提交后）</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># 二、</span><br><span class="line">-- 开启事务</span><br><span class="line">start transaction 或 begin transaction;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line">-- 回滚事务</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">commit;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h4><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还未提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时发现数据已经存在</td></tr></tbody></table><h5 id="并发事务隔离级别"><a href="#并发事务隔离级别" class="headerlink" title="并发事务隔离级别"></a>并发事务隔离级别</h5><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><h6 id="查看事务隔离级别"><a href="#查看事务隔离级别" class="headerlink" title="查看事务隔离级别"></a>查看事务隔离级别</h6><p><code>select @@TRANSACTION_ISOLATION;</code></p><h6 id="设置事务隔离级别"><a href="#设置事务隔离级别" class="headerlink" title="设置事务隔离级别"></a>设置事务隔离级别</h6><p><code>set [ SESSION | GLOBAL ] TRANSACTION ISOLATION  LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code></p><p>SESSION是会话级别，表示只针对当前会话有效，GLOBAL表示对所有会话有效</p><h4 id="四大特性ACID"><a href="#四大特性ACID" class="headerlink" title="四大特性ACID"></a>四大特性ACID</h4><ul><li>原子性(Atomicity)：事务是不可分割的最小操作</li><li>一致性(Consistency)：事务完成时，必须使所有数据</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库数据的改变即永久的</li></ul><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>原子性：保证每一列不可再分</p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>在满足第一范式的前提下实现每张表只描述一件事</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>满足第一和第二范式的前提下实现确保数据表中每一列数据都和主键直接相关</p><h4 id="反范式适用场景"><a href="#反范式适用场景" class="headerlink" title="反范式适用场景"></a>反范式适用场景</h4><p>反范式通过增加冗余字段实现空间换时间从而提高查询的效率，但这会使得：</p><ul><li>存储空间变大</li><li>一个表中字段做了修改，另一表中冗余字段也要同步修改，不然会导致数据不一致</li><li>若存储过程支持数据的更新、删除等操作。操作频繁会消耗系统资源</li><li>在数据量小的情况下反范式不能体现性能的优势</li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="克隆表"><a href="#克隆表" class="headerlink" title="克隆表"></a>克隆表</h4><p>将数据表的数据记录生成到新的表中</p><ul><li><p>使用like</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#复制 AREA_INFO 表结构生成 AREA_CLONE1 表</span><br><span class="line">CREATE TABLE AREA_CLONE1 LIKE AREA_INFO;</span><br><span class="line">INSERT INTO AREA_CLONE1 SELECT * FROM AREA_INFO;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接克隆（无法复制原表的主键、自动增长、约束、索引等配置；用like可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 克隆表名(SELECT * FROM 源表名);</span><br><span class="line">SHOW CREATE TABLE 克隆表名\G;#获取数据表的表结构、索引等信息</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="删除记录后主键记录从头开始自增"><a href="#删除记录后主键记录从头开始自增" class="headerlink" title="删除记录后主键记录从头开始自增"></a>删除记录后主键记录从头开始自增</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名;</span><br><span class="line">#DELETE清空表后，返回的结果内有删除的记录条目；DELETE工作时是一行一行的删除记录数据的；如果表中有自增长字段，使用DELETE FROM 删除所有记录后，再次新添加的记录会从原来最大的记录 ID 后面继续自增写入记录。</span><br><span class="line"></span><br><span class="line">truncate table 表名;</span><br><span class="line">#TRUNCATE 清空表后，没有返回被删除的条目；TRUNCATE 工作时是将表结构按原样重新建立，因此在速度上 TRUNCATE 会比 DELETE 清空表快；使用 TRUNCATE TABLE 清空表内数据后，ID 会从 1 开始重新记录。相当于直接格式化表</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建临时表"><a href="#创建临时表" class="headerlink" title="创建临时表"></a>创建临时表</h4><p>临时表是在当前连接中生效的表</p><ul><li>临时表创建成功后，使用<code>SHOW TABLES</code>命令是看不到创建的临时表的</li><li>临时表会在连接退出后被销毁，在退出之前也可执行增删改查操作</li></ul><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="克隆表-1"><a href="#克隆表-1" class="headerlink" title="克隆表"></a>克隆表</h3><p>将数据表的数据记录生成到新的表中</p><ul><li><p>使用like</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#复制 AREA_INFO 表结构生成 AREA_CLONE1 表</span><br><span class="line">CREATE TABLE AREA_CLONE1 LIKE AREA_INFO;</span><br><span class="line">INSERT INTO AREA_CLONE1 SELECT * FROM AREA_INFO;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>直接克隆（无法复制原表的主键、自动增长、约束、索引等配置；用like可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 克隆表名(SELECT * FROM 源表名);</span><br><span class="line">SHOW CREATE TABLE 克隆表名\G;#获取数据表的表结构、索引等信息</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>删除记录后主键记录从头开始自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名;</span><br><span class="line">#DELETE清空表后，返回的结果内有删除的记录条目；DELETE工作时是一行一行的删除记录数据的；如果表中有自增长字段，使用DELETE FROM 删除所有记录后，再次新添加的记录会从原来最大的记录 ID 后面继续自增写入记录。</span><br><span class="line"></span><br><span class="line">truncate table 表名;</span><br><span class="line">#TRUNCATE 清空表后，没有返回被删除的条目；TRUNCATE 工作时是将表结构按原样重新建立，因此在速度上 TRUNCATE 会比 DELETE 清空表快；使用 TRUNCATE TABLE 清空表内数据后，ID 会从 1 开始重新记录。相当于直接格式化表</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p><img src="https://s1.ax1x.com/2023/02/13/pSoKwJH.png"></p><p><img src="https://s1.ax1x.com/2023/02/13/pSoKUoD.png"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎，默认存储引擎为InnoDB</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>支持事务；行级锁，提高并发访问性能；支持外键</p><p>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引</p><ul><li>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</li></ul><p>查看mysql变量：<code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据(在cmd运行)：<code>ibd2sdi xxx.ibd</code></p><p><img src="https://s1.ax1x.com/2023/02/13/pSoKdFe.png"></p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>mysql早期默认存储引擎；不支持事务和外键、支持表锁，不支持行锁、访问速度快</p><p>xxx.sdi: 存储表结构信息；xxx.MYD: 存储数据；xxx.MYI: 存储索引</p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>表数据存在内存中，受硬件、断电问题的影响，只能将这些表作为临时表或缓存</p><p>存放在内存中，速度快；hash索引；xxx.sdi: 存储表结构信息</p><h4 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h4><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N&#x2F;A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h4 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h4><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎；对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合</p><ul><li>InnoDB：若应用对事物的完整性有较高要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多更新、删除操作</li><li>MyISAm：若应用以读和插入操作为主，只有很少的更新和删除操作，且对事物完整性、并发性要求不高</li><li>Memory：将所有数据保存在内存中，访问速度快，常用于临时表及缓存，对表的大小有限制，无法保障数据的安全性</li></ul><p>电商中足迹和评论适合使用MyISAm，缓存适合用Memory</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h4><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：</p><ul><li>查看全局数据：<code>show global status like &#39;Com_______&#39;;</code></li><li>查看当前会话：<code>show session status like &#39;Com_______&#39;;</code></li></ul><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</span><br><span class="line"># 开启慢查询日志开关</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br><span class="line">更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看慢查询日志开关状态：<code>show variables like &#39;slow_query_log&#39;;</code></li></ul><h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>在做SQL优化时了解时间耗费在哪，通过<code>have_profiling</code>参数可以看到当前mysql是否支持profile操作：</p><p><code>select @@have_profiling;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- profilling默认关闭，可以通过set语句在session/global级别开启profilling</span><br><span class="line">set profiling = 1;</span><br><span class="line">-- 查看所有语句的耗时</span><br><span class="line">show profiles;</span><br><span class="line">-- 查看指定query_id的SQL语句各个阶段的耗时</span><br><span class="line">show profile for query query_id;</span><br><span class="line">-- 查看指定query_id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序</p><ul><li>获取表是否顺序读取</li><li>获取数据读取操作的操作类型</li><li>获取哪些索引可以使用</li><li>获取哪些索引实际被使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><code>explain select 字段列表 from 表名 where 条件 </code> </p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</td></tr><tr><td>select_type</td><td>表示select的类型，常见取值有：SIMPLE(简单表，即不适用表连接或子查询)、PRIMARY(主查询，即外层查询)、UNION(UNION中的第二个或后面的查询语句)、SUBQUERY(SELECT&#x2F;WHERE之后包含了子查询)等</td></tr><tr><td>type</td><td>连接类型，性能由好到差的连接类型为：NULL、system、const、eq_ref、ref、range、index、all</td></tr><tr><td>possible_key</td><td>可能应用在这张表上的索引，一个或多个</td></tr><tr><td>key</td><td>实际使用的索引，若为NULL，则没有索引</td></tr><tr><td>key_len</td><td>索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</td></tr><tr><td>rows</td><td>mysql认为必须要执行的行数，在InnoDB的表中该值可能不准确</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比，值越大越好</td></tr></tbody></table><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查询算法</p><p><strong>优点：</strong></p><ul><li>提高数据检索效率，降低数据库io成本，类似于书的目录</li><li>通过索引列对数据排序，降低数据排序成本和CPU的消耗</li></ul><p><strong>缺点：</strong></p><ul><li>索引列也要占用空间</li><li>索引大大提高了查询效率，但降低了更新的速度，如INSERT、UPDATE、DELETE</li></ul><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p><img src="https://s1.ax1x.com/2023/02/13/pSoMZpd.md.png"></p><p>二叉树的缺点可以用红黑树来解决：</p><p><img src="https://s1.ax1x.com/2023/02/13/pSoMEfH.md.png"></p><p>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://s1.ax1x.com/2023/02/13/pSoK5Ss.png"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p><img src="https://s1.ax1x.com/2023/02/13/pSoKIln.md.png"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能</p><p><img src="https://s1.ax1x.com/2023/02/13/pSoKoyq.md.png"></p><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>哈希索引即采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中；如果两个（或多个）键值映射到一个相同的槽位上就产生了hash冲突（也称为hash碰撞），可以通过链表来解决</p><p><img src="https://s1.ax1x.com/2023/02/13/pSoKTO0.png"></p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li><li>存储引擎支持：Memory、InnoDB（具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的）</li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h5 id="MyIsam索引"><a href="#MyIsam索引" class="headerlink" title="MyIsam索引"></a>MyIsam索引</h5><h6 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h6><p>表user的索引存储在索引文件<code>user.MYI</code>中，数据文件存储在数据文件 <code>user.MYD</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id = 28;</span><br><span class="line"></span><br><span class="line"># 先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路（1次磁盘IO）</span><br><span class="line"># 将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索（1次磁盘IO）</span><br><span class="line"># 检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28=28。查找到值等于30的索引项（1次磁盘IO）</span><br><span class="line"># 从索引项中获取磁盘地址，然后到数据文件user.MYD中获取对应整行记录（1次磁盘IO）</span><br><span class="line"># 将记录返回给客户端</span><br><span class="line"></span><br><span class="line"># 磁盘IO次数：3次索引检索+记录数据检索</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSopdPO.md.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id between 28 and 47;</span><br><span class="line"></span><br><span class="line"># 先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路（1次磁盘IO）</span><br><span class="line"># 将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索（1次磁盘IO）</span><br><span class="line"># 检索到叶节点，将节点加载到内存中遍历比较16&lt;28，18&lt;28，28=28&lt;47。查找到值等于28的索引项；根据磁盘地址从数据文件中获取行记录缓存到结果集中（1次磁盘IO）；查询语句时范围查找，需要向后遍历底层叶子链表，直至到达最后一个不满足筛选条件</span><br><span class="line"># 向后遍历底层叶子链表，将下一个节点加载到内存中，遍历比较，28&lt;47=47，根据磁盘地址从数据文件中获取行记录缓存到结果集中（1次磁盘IO）</span><br><span class="line"># 最后得到两条符合筛选条件，将查询结果集返给客户端</span><br><span class="line"></span><br><span class="line"># 磁盘IO次数：4次索引检索+记录数据检索</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSoP2Ix.png"></p><h6 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h6><p>在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复；查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据</p><h5 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h5><h6 id="主键索引（聚簇索引）"><a href="#主键索引（聚簇索引）" class="headerlink" title="主键索引（聚簇索引）"></a>主键索引（聚簇索引）</h6><p>每个InnoDB表都有一个聚簇索引 ，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录；当一个表没有创建主键索引时，InnoDB会自动创建一个ROWID字段来构建聚簇索引</p><blockquote><p>1、在表上定义主键PRIMARY KEY，InnoDB将主键索引用作聚簇索引</p><p>2、若表没有定义主键，InnoDB会选择第一个不为NULL的唯一索引列用作聚簇索引</p><p>3、若以上两个都没有，InnoDB 会用一个6 字节长整型的隐式字段 ROWID字段构建聚簇索引。该ROWID字段会在插入新行时自动递增</p></blockquote><p>除聚簇索引外的所有索引都称为辅助索引；辅助索引中的叶子节点存储的数据是该行的主键值，检索时，InnoDB使用此主键值在聚簇索引中搜索行记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 以user_innodb为例，user_innodb的id列为主键，age列为普通索引</span><br><span class="line">CREATE TABLE `user_innodb`</span><br><span class="line">(</span><br><span class="line">  `id`       int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age`      int(11)     DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  KEY `idx_age` (`age`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSoFq8f.png"></p><p><img src="https://s1.ax1x.com/2023/02/13/pSoknaR.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 等值查询数据</span><br><span class="line">select * from user_innodb where id = 28;</span><br><span class="line"></span><br><span class="line"># 先在主键树中从根节点开始检索，将根节点加载到内存，比较28&lt;75，走左路（1次磁盘IO）</span><br><span class="line"># 将左子树节点加载到内存中，比较16&lt;28&lt;47，向下检索（1次磁盘IO）</span><br><span class="line"># 检索到叶节点，将节点加载到内存中遍历，比较16&lt;28，18&lt;28，28=28。查找到值等于28的索引项，直接可以获取整行数据。将改记录返回给客户端（1次磁盘IO）</span><br><span class="line"></span><br><span class="line"># 磁盘IO数量：3次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSokuI1.png"></p><h6 id="辅助索引-1"><a href="#辅助索引-1" class="headerlink" title="辅助索引"></a>辅助索引</h6><p>除聚簇索引之外的所有索引都称为辅助索引，InnoDB的辅助索引只会存储主键值而非磁盘地址</p><p><img src="https://s1.ax1x.com/2023/02/13/pSokmZ9.png"></p><p>底层叶子节点的按照（age，id）的顺序排序，先按照age从小到大排序，age列相同时按照id列排序；使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后使用主键到主索引中检索记录（该过程称为回表查询）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user_innodb where age=19;</span><br><span class="line"></span><br><span class="line"># 磁盘IO数：辅助索引3次+获取记录回表3次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSokMPx.png"></p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p><code>频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大,更好地使用覆盖索引优化</code></p><p>表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)；（遵循最左匹配原则；先比较a，b在a等值时有序，c在ab等值时有序）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `abc_innodb`</span><br><span class="line">(</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a`  int(11)     DEFAULT NULL,</span><br><span class="line">  `b`  int(11)     DEFAULT NULL,</span><br><span class="line">  `c`  varchar(10) DEFAULT NULL,</span><br><span class="line">  `d`  varchar(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  KEY `idx_abc` (`a`, `b`, `c`)</span><br><span class="line">) ENGINE = InnoDB;</span><br><span class="line"></span><br><span class="line">select * from abc_innodb order by a, b, c, id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/13/pSoEZNR.png"></p><p><img src="https://s1.ax1x.com/2023/02/13/pSoEVE9.png"></p><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>常用的优化手段，因为在使用附辅助索引时只可以拿到主键值，还需根据主键进行主键索引获取数据；但若如上所示只需abc字段时，则查询到组合索引的叶子节点就可以返回了，不需要回表查询</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>创建索引：<code>create [ unique | fulltext ] index index_name on table_name (index_col_name, ...);</code></li><li>查看索引：<code>show index from table_name;</code></li><li>删除索引：<code>drop index index_name on table_name;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- name字段为姓名字段，该字段值可能重复，为该字段创建索引</span><br><span class="line">create index idx_user_name on tb_user(name);</span><br><span class="line">-- phone手机号字段的值非空且唯一，为该字段创建唯一索引</span><br><span class="line">create unique index idx_user_phone on tb_user(phone);</span><br><span class="line">-- 为profession，age，status创建联合索引</span><br><span class="line">create index idx_user_pro_age_stat on tb_user(profession,age,status);</span><br><span class="line">-- 为email建立合适的索引提升查询效率</span><br><span class="line">create index idx_user_email on tb_user(email);</span><br><span class="line">-- 删除索引</span><br><span class="line">drop index idx_user_email on ta_user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ol><li>在索引列上进行运算操作或使用了函数，索引将失效，如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li><li>字段类型不同，如：<code>explain select * from tb_user where phone = 17799990015;</code>，phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效</li><li>联合索引不满足最左匹配原则</li></ol><h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>其中<code>use</code>是建议，实际使用哪个索引MySQL还会自己权衡运行速度去更改，force即无论如何都强制使用该索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 使用索引</span><br><span class="line">explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</span><br><span class="line">-- 不使用哪个索引</span><br><span class="line">explain select * from tb_user ignore index(idx_user_pro) where</span><br><span class="line">profession=&quot;软件工程&quot;;</span><br><span class="line">-- 必须使用哪个索引</span><br><span class="line">explain select * from tb_user force index(idx_user_pro) where</span><br><span class="line">profession=&quot;软件工程&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>针对数据量大且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>若是字符串类型的字段，字段长度较长，可以针对字段的特点建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，可以更好地确定哪个索引最有效地用于查询</li></ul><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="基础SQL优化"><a href="#基础SQL优化" class="headerlink" title="基础SQL优化"></a>基础SQL优化</h4><ul><li>尽量使用数值替代字符串类型</li><li>索引不适合建在有大量重复数据的字段上</li><li>避免在where子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符，可能会让索引失效</li><li>用<code>union all</code>或分成两个子句替换<code>or</code>来连接条件</li><li>使用默认值代替<code>null</code></li></ul><h4 id="高级SQL优化"><a href="#高级SQL优化" class="headerlink" title="高级SQL优化"></a>高级SQL优化</h4><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><ul><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ul><p>若一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以用MySQL数据库提供的load指令插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 --local-infile（这行在bash/cmd界面输入）</span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1；</span><br><span class="line">select @@local_infile;</span><br><span class="line"># 执行load指令将准备好的数据加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27;</span><br><span class="line">fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><p>避免同时修改或删除过多数据，cpu利用率过高造成锁表操作，从而影响对数据库的访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 反例</span><br><span class="line">delete from student where id &lt; 100000;</span><br><span class="line"></span><br><span class="line">for (User user:list) &#123;</span><br><span class="line">delete from student;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 正例</span><br><span class="line"># 分批进行删除，如每次500</span><br><span class="line">for() &#123;</span><br><span class="line">delete student where id &lt; 500;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete student where id &gt;= 500 and id &lt; 1000;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="先过滤再使用group-by分组"><a href="#先过滤再使用group-by分组" class="headerlink" title="先过滤再使用group by分组"></a>先过滤再使用group by分组</h5><h5 id="排序字段创建索引（where和order-by常出现的字段）"><a href="#排序字段创建索引（where和order-by常出现的字段）" class="headerlink" title="排序字段创建索引（where和order by常出现的字段）"></a>排序字段创建索引（where和order by常出现的字段）</h5><h5 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h5><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><p>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</p><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul></li><li><p>某表包含字段（id、username、password、status），由于数据量大，需要对以下SQL语句进行优化：</p><p><code>select id,username,password from tb_user where username=&#39;itcast&#39;;</code></p><p><code>解：</code>给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux笔记</title>
      <link href="/linux%E7%AC%94%E8%AE%B0/"/>
      <url>/linux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p><code>[Ctrl]-d</code>：可以用于取代exit的输入</p><h3 id="虚拟机目录"><a href="#虚拟机目录" class="headerlink" title="虚拟机目录"></a>虚拟机目录</h3><p><img src="https://s1.ax1x.com/2023/03/21/ppUSxX9.jpg"></p><h4 id="目录含义"><a href="#目录含义" class="headerlink" title="目录含义"></a>目录含义</h4><p><code>/bin</code>：存放经常使用的命令</p><p><code>/home</code>：存放普通用户的主目录，一般该目录名是以用户的账号命名</p><p><code>/root</code>：该目录为系统管理员，也称作超级权限者的用户主目录</p><p><code>/boot</code>：Linux启动相关文件</p><p><code>/lib</code>：系统开机所需最基本的动态连接共享库，作用类似Windows里的DLL文件</p><p><code>/lost+found</code>：一般情况下是空的，当系统非法关机后存放了一些文件</p><p><code>/etc</code>：系统管理所需配置和子文件目录</p><p><code>/user</code>：用户应用程序和文件</p><p><code>/proc</code>：虚拟目录，系统内存映射，访问这个目录获取系统信息</p><p><code>/srv</code>：存放服务启动后所需数据</p><p><code>/sys</code>：该目录安装了2.6内核新出现的文件系统</p><p><code>/tmp</code>：存放临时文件</p><p><code>/mnt</code>：存放挂载文件</p><p><code>/opt</code>：给主机额外安装软件的目录，即软件存放目录</p><p><code>/user/local</code>：软件安装后的目标目录，一般是编译源码的方式安装的程序</p><h4 id="颜色含义"><a href="#颜色含义" class="headerlink" title="颜色含义"></a>颜色含义</h4><p>蓝色表示目录，白色表示文件，红色表示压缩文件，绿色表示可执行权限</p><h3 id="Linux启动过程"><a href="#Linux启动过程" class="headerlink" title="Linux启动过程"></a>Linux启动过程</h3><p>可以分为5个阶段：</p><ul><li>内核的引导</li><li>运行<code>init</code></li><li>系统初始化</li><li>建立终端</li><li>用户登录系统</li></ul><blockquote><p>init程序的类型：</p><ul><li><strong>SysV:</strong> init, CentOS 5之前, 配置文件： &#x2F;etc&#x2F;inittab</li><li><strong>Upstart:</strong> init,CentOS 6, 配置文件： &#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init&#x2F;*.conf</li><li><strong>Systemd：</strong> systemd, CentOS 7,配置文件： &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system &#x2F;etc&#x2F;systemd&#x2F;system</li></ul></blockquote><h4 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h4><p><code>BIOS</code>开机自检，按照设置的启动设备（通常是硬盘）启动，操作系统接管硬件后首先读入<code>/boot</code>下的内核文件</p><h4 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a>运行init</h4><p>init进程是所有进程的起点，init程序首先需要读取配置文件<code>/etc/inittab</code></p><h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><p>许多程序需要开机启动，在Windows叫做服务（service），在Linux就叫做守护进程（daemon）</p><p>init进程的一大任务即运行这些开机启动的程序，但是不同场合需启动不同程序，Linux允许为不同场合分配不同的开机启动程序（运行级别）</p><p>Linux系统有7个运行级别(runlevel)：</p><ul><li>运行级别0：系统停机状态，系统默认级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态(没有NFS，网络文件系统)</li><li>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登录后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认级别不能设为6，否则不能正常启动</li></ul><h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>在init的配置文件中有这么一行：si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了<code>/etc/rc.d/rc.sysinit</code>，而<code>rc.sysinit</code>是一个bash shell的脚本，<code>rc.sysinit</code>是每一个运行级别都要首先运行的重要脚本，它主要完成的工作有：激活交换分区、检查磁盘、加载硬件模块以及其它一些需要优先执行的任务</p><h4 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h4><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure><p>2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式</p><h3 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h3><h4 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h4><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><p>使用Vim编辑器时默认处于命令模式，该模式下可以移动光标位置，可以通过快捷键对文件内容进行复制、粘贴、删除等操作</p><h6 id="如何进入命令模式"><a href="#如何进入命令模式" class="headerlink" title="如何进入命令模式"></a>如何进入命令模式</h6><p>当使用vim命令直接打开某个文件时，默认进入的就是命令模式；若处于其它模式时连续按两次Esc键也可以返回命令模式</p><h5 id="编辑模式或输入模式"><a href="#编辑模式或输入模式" class="headerlink" title="编辑模式或输入模式"></a>编辑模式或输入模式</h5><p>在命令模式下输入小写字母a或i即可进入编辑模式</p><h5 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h5><p>可以在末行输入命令对文件进行查找、替换、保存、退出等操作</p><h6 id="如何进入末行模式"><a href="#如何进入末行模式" class="headerlink" title="如何进入末行模式"></a>如何进入末行模式</h6><p>进入末行模式的方法只有一个，在命令模式下使用<code>:</code>或<code>/</code>的方式进入</p><h5 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h5><p>可以做一些列选操作（通过方向键选择某些列的内容，类似Windows鼠标刷黑）</p><h6 id="如何进入可视化模式"><a href="#如何进入可视化模式" class="headerlink" title="如何进入可视化模式"></a>如何进入可视化模式</h6><p>在命令模式中，按<code>ctrl+v（可视块）</code>或<code>ctrl+V（可视行）</code>或<code>v（可视）</code>，然后根据方向键选择需要复制的区块，按下<code>y</code>进行复制，最后按下<code>p</code>粘贴</p><p>退出可视模式按下<code>Esc</code></p><h5 id="四种模式的关系"><a href="#四种模式的关系" class="headerlink" title="四种模式的关系"></a>四种模式的关系</h5><p><img src="https://s1.ax1x.com/2023/02/03/pSsnXVS.png"></p><h4 id="各模式下的相关操作"><a href="#各模式下的相关操作" class="headerlink" title="各模式下的相关操作"></a>各模式下的相关操作</h4><h5 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h5><h6 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h6><p>向下移动30行 &#x3D;&gt; 30↓</p><p>光标向右移动0n个字符 &#x3D;&gt; n&lt;space&gt;</p><p>移动到该行的最前面的字符处 &#x3D;&gt; 0</p><p>移动到该行的最后面的字符处 &#x3D;&gt; $</p><p>移动到这个屏幕的最上方那一行的第一个字符 &#x3D;&gt; H</p><p>移动到这个屏幕的中央那一行的第一个字符 &#x3D;&gt; M</p><p>移动到这个屏幕的最下方那一行的第一个字符 &#x3D;&gt; L</p><p>移动到这个档案的第一行 &#x3D;&gt; gg</p><p>移动到这个档案的最后一行 &#x3D;&gt; G</p><p>移动光标到第150行 &#x3D;&gt; 150G</p><p>光标向下移动n行 &#x3D;&gt; n&lt;Enter&gt;</p><h6 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h6><p>向上翻屏：<code>ctrl + b（before）或 PgUp</code></p><p>向下翻屏：<code>ctrl + f（after）或 PgDn</code></p><p>向上翻半屏：<code>ctrl + u（up）</code></p><p>向下翻半屏：<code>ctrl + d（down）</code></p><h6 id="复制-x2F-粘贴"><a href="#复制-x2F-粘贴" class="headerlink" title="复制&#x2F;粘贴"></a>复制&#x2F;粘贴</h6><p>复制当前行（光标所在那一行）&#x3D;&gt; yy，如复制5行，5yy</p><p>粘贴：在想要粘贴的地方按下p【将粘贴光标所在行的下一行】，如果想粘贴光标所在行之前可以使用P键</p><h6 id="剪切-x2F-删除"><a href="#剪切-x2F-删除" class="headerlink" title="剪切&#x2F;删除"></a>剪切&#x2F;删除</h6><p>在Vim中，剪切和删除都是<code>dd</code>，若未用p进行粘贴就是删除；粘贴了就是剪切</p><p>剪切&#x2F;删除光标所在当前行之后的内容，但是删除之后下一行不上移按键：D（删除之后当前行会变成空白行）</p><h6 id="撤销-x2F-恢复"><a href="#撤销-x2F-恢复" class="headerlink" title="撤销&#x2F;恢复"></a>撤销&#x2F;恢复</h6><p>撤销：u（undo）</p><p>恢复：ctrl + r恢复（取消）之前的撤销操作【重做，redo】</p><h5 id="末行模式-1"><a href="#末行模式-1" class="headerlink" title="末行模式"></a>末行模式</h5><h6 id="查找-x2F-搜索"><a href="#查找-x2F-搜索" class="headerlink" title="查找&#x2F;搜索"></a>查找&#x2F;搜索</h6><p>在命令模式下输入<code>/</code>，进入末行模式后输入要查找或搜索的关键词</p><p>若在一个文件中存在多个满足条件的结果。在搜索结果中切换上&#x2F;下一个结果：N&#x2F;n（大写N代表上一个结果，小写n代表next）</p><p>若不需要高亮，则在末行模式输入<code>:noh</code>【no highlight】</p><h6 id="文件内容的替换"><a href="#文件内容的替换" class="headerlink" title="文件内容的替换"></a>文件内容的替换</h6><p>第一步：首先进入末行模式</p><p>第二步：根据需求替换内容</p><p>只替换光标所在行第一个满足的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/要替换的关键词/替换后的关键词+回车</span><br></pre></td></tr></table></figure><p>替换光标所在行所有满足条件的结果（替换多次，只能替换一行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/要替换的关键词/替换后的关键词/gg=global全局替换</span><br></pre></td></tr></table></figure><p>针对整个文档中的所有行进行替换，只替换每一行中满足条件的第一个结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/要替换的关键词/替换后的关键词</span><br></pre></td></tr></table></figure><p>针对整个文档中的所有关键词进行替换（只要满足条件就进行替换操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/要替换的关键词/替换后的关键词/g</span><br></pre></td></tr></table></figure><h6 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set nu</span><br><span class="line">【nu = number】，行号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取消行号 =&gt; :set nonu</span><br></pre></td></tr></table></figure><h6 id="set-paste模式"><a href="#set-paste模式" class="headerlink" title="set paste模式"></a>set paste模式</h6><p>为什么要使用paste模式？</p><p>在终端Vim中粘贴代码时会发现插入的代码有多余的缩进，且逐行累加。原因是终端把粘贴的文本存入键盘缓存（Keyboard Buffer）中，Vim则把这些内容作为用户的键盘输入来处理。导致在遇到换行符的时候，如果Vim开启了自动缩进，就会默认的把上一行缩进插入到下一行的开头，最终使代码变乱。</p><p>在粘贴数据之前开启paste模式：<code>:set paste</code></p><p>在粘贴完毕后关闭paste模式：<code>:set nopaste</code></p><h4 id="Vim实用功能"><a href="#Vim实用功能" class="headerlink" title="Vim实用功能"></a>Vim实用功能</h4><h5 id="代码着色"><a href="#代码着色" class="headerlink" title="代码着色"></a>代码着色</h5><p>通过<code>:syntax on</code>或<code>:syntax off</code> 开启或关闭代码着色功能</p><h5 id="异常退出解决方案"><a href="#异常退出解决方案" class="headerlink" title="异常退出解决方案"></a>异常退出解决方案</h5><p>突然关闭终端或断电下退出的情况为异常退出，文件一般为<code>.文件名称.swp</code></p><p>解决办法：将交换文件直接删除</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">添加用户：useradd 用户名</span><br><span class="line">给用户指定密码：passwd 用户名</span><br><span class="line">删除用户（保留家目录）：userdel 用户名</span><br><span class="line">删除用户（删除所有目录）：userdel -r 用户名</span><br><span class="line">查询用户信息：id 用户名</span><br><span class="line">查看当前登录用户：who am i</span><br></pre></td></tr></table></figure><h3 id="CentOS7找回root密码"><a href="#CentOS7找回root密码" class="headerlink" title="CentOS7找回root密码"></a>CentOS7找回root密码</h3><ol><li>启动系统，进入开机页面，按<code>e</code>键进入编辑页面</li><li>光标向下移动，找到“Linux16”开头的行数，行末输入<code>init=/bin/sh</code>，接着按<code>ctrl+x</code>进入单用户模式</li><li>在光标闪烁位置输入：mount -o remount,rw &#x2F;，完成后回车</li><li>接着输入passwd，完成后回车，输入密码后回车，再次输入密码，修改成功后会显示passwd…</li><li>接着在光标位置输入：touch &#x2F; .autorelabel，完成后回车，等待系统重启，新密码生效</li></ol><h3 id="开关机问题"><a href="#开关机问题" class="headerlink" title="开关机问题"></a>开关机问题</h3><p><code>sync</code>：将内存中尚未更新的数据写入硬盘中；目前的shutdown&#x2F;reboot&#x2F;halt等指令均在关机前进行了sync</p><p><code>shutdown</code>：只有root拥有该权限</p><table><thead><tr><th>选项与参数</th><th>说明</th></tr></thead><tbody><tr><td>-t sec</td><td>-t后面加秒数，即几秒后关机</td></tr><tr><td>-k</td><td>不是真的关机，只是发送警告讯息</td></tr><tr><td>-r</td><td>在系统服务停掉后重新启动（常用）</td></tr><tr><td>-h</td><td>在系统服务停掉后立即关机</td></tr><tr><td>-n</td><td>不经过init程序，直接以shutdown功能关机</td></tr><tr><td>-f</td><td>关机并开机后，强制略过fsck的磁盘检查</td></tr><tr><td>-c</td><td>取消已经在进行的shutdown指令内容</td></tr></tbody></table><p><code>忘记root密码</code>：</p><ol><li><p>启动虚拟机并按e进入下列页面</p><p><img src="https://img-blog.csdnimg.cn/4426447226b8445b8df7c8e3ee63a1fb.png"></p></li><li><p>用键盘上下移动光标，到linuix…UTF-8后面加上rd.break,按下Ctrl+x</p><p><img src="https://img-blog.csdnimg.cn/f6ca6a8701094d31a4f55380a88f9b63.png"></p></li><li><p>接下来进入switch_root页面里，输入</p><p># mount -o remount,rw &#x2F;sysroot</p><p># chroot &#x2F;sysroot</p></li><li><p>之后就会进入sh-4.2#的页面输入passwd，输入你的新密码（直接输入就行了，不显示字符）</p><p><img src="https://img-blog.csdnimg.cn/181e7534a8804eb4b9acb5fdf0897941.png"></p></li><li><p>输入touch &#x2F; .autorelabel</p><p>输入exit回到switch_root页面</p><p>再次输入exit</p></li></ol><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><h4 id="查看文件属性"><a href="#查看文件属性" class="headerlink" title="查看文件属性"></a>查看文件属性</h4><p><code>ls [-al]</code>显示文件名及相关属性</p><p><img src="https://s1.ax1x.com/2023/02/03/pSsnqDf.png"></p><p><img src="https://s1.ax1x.com/2023/02/03/pSsn7vt.png"></p><ul><li>第一个字符代表文件类型[目录、档案或链接文件等]<ul><li>当为[d]则是目录</li><li>当为[-]则是档案</li><li>若为[|]则表示为连结档（link file）</li><li>若是[b]则表示为装置文件内的可供储存的接口设备（可随机存取装置）</li><li>若是[c]则表示为装置文件内的串行端口设备，例如键盘、鼠标（一次性读取装置）</li></ul></li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合，若无权限则以<code>-</code>表示</p><h4 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h4><h5 id="chgrp：更改文件属组"><a href="#chgrp：更改文件属组" class="headerlink" title="chgrp：更改文件属组"></a>chgrp：更改文件属组</h5><p><code>chgrp [-R] 属组名 文件名</code></p><ul><li><code>-R</code>：递归更改文件属组，若加上该参数，目录下的所有文件的属组都会更改</li></ul><h5 id="chown：更改文件属主或属组"><a href="#chown：更改文件属主或属组" class="headerlink" title="chown：更改文件属主或属组"></a>chown：更改文件属主或属组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名:属组名 文件名</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="chmod：更改文件的9个属性"><a href="#chmod：更改文件的9个属性" class="headerlink" title="chmod：更改文件的9个属性"></a>chmod：更改文件的9个属性</h5><p>Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute权限</p><p>其中字符权限对应的数字为：<code>r:4 w:2 x:1</code></p><p>故当权限为<code>-rwxrwx---</code>时对应的权限为<code>owner:7 group:7 others:0</code></p><h6 id="数字修改权限"><a href="#数字修改权限" class="headerlink" title="数字修改权限"></a>数字修改权限</h6><p><code>chmod [-R] xyz 文件或目录</code></p><ul><li><strong>xyz</strong> : 即数字类型的权限属性，为 <strong>rwx</strong> 属性数值的相加</li><li><strong>-R</strong> : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul><h6 id="字符修改权限"><a href="#字符修改权限" class="headerlink" title="字符修改权限"></a>字符修改权限</h6><table><thead><tr><th>chmod</th><th>u g o a</th><th>+(加入) -(除去) &#x3D;(设定)</th><th>r w x</th><th>文件或目录</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><code>chmod u=rwx,g=rx,o=r 文件名</code></p><p>若要去掉全部人的可执行权限，可以：<code>chmod a-x</code></p><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>Linux 磁盘管理常用三个命令为 <strong>df</strong>、<strong>du</strong> 和 <strong>fdisk</strong>：</p><ul><li><code>df</code>：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况</li><li><code>du</code>：检查磁盘空间使用量，是对文件和目录磁盘使用的空间查看</li><li><code>fdisk</code>：用于磁盘分区</li></ul><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p><code>df [-ahikHTm] [目录或文件名]</code></p><ul><li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统</li><li>-k ：以 KBytes 的容量显示各文件系统</li><li>-m ：以 MBytes 的容量显示各文件系统</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示</li><li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p><code>du [-ahskm] 文件或目录名称</code></p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已</li><li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量</li><li>-S ：不包括子目录下的总计，与 -s 有点差别</li><li>-k ：以 KBytes 列出容量显示</li><li>-m ：以 MBytes 列出容量显示</li></ul><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p><code>fdisk [-l] 装置名称</code></p><ul><li><code>-l</code>：输出后面接的装置所有的分区内容，仅为<code>fdisk -l</code>时会将整个系统的装置分区均列出来</li></ul><h4 id="mkfs：磁盘格式化"><a href="#mkfs：磁盘格式化" class="headerlink" title="mkfs：磁盘格式化"></a>mkfs：磁盘格式化</h4><p><code>mkfs [-t 文件系统格式] 装置文件名</code></p><ul><li>-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</li></ul><h6 id="查看mkfs支持的文件格式"><a href="#查看mkfs支持的文件格式" class="headerlink" title="查看mkfs支持的文件格式"></a>查看mkfs支持的文件格式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mkfs[tab][tab]</span><br><span class="line">mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.msdos   mkfs.vfat</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="将分区-x2F-dev-x2F-hdc6格式化为-ext3-文件系统"><a href="#将分区-x2F-dev-x2F-hdc6格式化为-ext3-文件系统" class="headerlink" title="将分区 &#x2F;dev&#x2F;hdc6格式化为 ext3 文件系统"></a>将分区 &#x2F;dev&#x2F;hdc6格式化为 ext3 文件系统</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# mkfs -t ext3 /dev/hdc6</span><br><span class="line">mke2fs 1.39 (29-May-2006)</span><br><span class="line">Filesystem label=                &lt;==这里指的是分割槽的名称(label)</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)          &lt;==block 的大小配置为 4K </span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">251392 inodes, 502023 blocks     &lt;==由此配置决定的inode/block数量</span><br><span class="line">25101 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=515899392</span><br><span class="line">16 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">15712 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">        32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (8192 blocks): done &lt;==有日志记录</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 34 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br><span class="line"># 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fsck：磁盘检验"><a href="#fsck：磁盘检验" class="headerlink" title="fsck：磁盘检验"></a>fsck：磁盘检验</h4><p>用于检查和维护不一致的文件系统，若系统掉电或磁盘发生问题，可用其对文件系统进行检查</p><p><code>fsck [-t 文件系统] [-ACay] 装置名称</code></p><ul><li>-t : 给定档案系统的型式，若在 &#x2F;etc&#x2F;fstab 中已有定义或 kernel 本身已支持的则不需加上此参数</li><li>-s : 依序一个一个地执行 fsck 的指令来检查</li><li>-A : 对&#x2F;etc&#x2F;fstab 中所有列出来的 分区（partition）做检查</li><li>-C : 显示完整的检查进度</li><li>-d : 打印出 e2fsck 的 debug 结果</li><li>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</li><li>-R : 同时有 -A 条件时，省略 &#x2F; 不检查</li><li>-V : 详细显示模式</li><li>-a : 如果检查有错则自动修复</li><li>-r : 如果检查有错则由使用者回答是否修复</li><li>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</li></ul><h4 id="mount、umount"><a href="#mount、umount" class="headerlink" title="mount、umount"></a>mount、umount</h4><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令</p><p><code>mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</code></p><p><code>umount [-fn] 装置文件名或挂载点</code></p><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下</li><li>-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除</li></ul><h3 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h3><p>任务调度：系统在某个时间执行特定的命令或程序</p><h4 id="任务调度分类"><a href="#任务调度分类" class="headerlink" title="任务调度分类"></a>任务调度分类</h4><ol><li><p>系统工作：某些重要工作周而复始的进行，如病毒查杀</p></li><li><p>个别用户工作：个别用户执行某些程序，如打开qq</p><p><strong>定时任务的设置：crontab [选项]</strong></p></li></ol><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>编辑crontab定时任务</td></tr><tr><td>-l</td><td>查询当前任务调度</td></tr><tr><td>-r</td><td>删除当前用户所有的定时任务</td></tr></tbody></table><h4 id="重启任务调度"><a href="#重启任务调度" class="headerlink" title="重启任务调度"></a>重启任务调度</h4><p>service crond restart</p><p>crontab -e 回车然后输入 *&#x2F;1 * * * * ls</p><table><thead><tr><th>*号位置</th><th>含义</th></tr></thead><tbody><tr><td>第一个</td><td>一小时当中的第几分钟（分钟）</td></tr><tr><td>第二个</td><td>一天当中的第几小时（小时）</td></tr><tr><td>第三个</td><td>一月当中的第几天（天）</td></tr><tr><td>第四个</td><td>一年中第几个月（月）</td></tr><tr><td>第五个</td><td>一周当中的星期几（范围0-7,0和7都表示星期天）</td></tr></tbody></table><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>表示任何时间，比如第一个*表示一小时每分钟都执行一次</td></tr><tr><td>,</td><td>表示不连续时间，比如”0 8,10 * * *”表示每天8点和10点执行</td></tr><tr><td>-</td><td>表示连续的时间范围，比如”0 2 * * 1-6”表示周一到周六凌晨2点执行一次命令</td></tr><tr><td>*&#x2F;n</td><td>表示每隔多久执行一次，如”*&#x2F;10 * * * *”表示每10分钟执行一次</td></tr></tbody></table><p><strong>特定时间执行案例</strong></p><p><img src="https://s1.ax1x.com/2023/02/03/pSsnLb8.png"></p><h4 id="at定时任务"><a href="#at定时任务" class="headerlink" title="at定时任务"></a>at定时任务</h4><p>at命令是一次性定时计划任务 ，at的守护进程atd会以后台模式检查作业队列运行。默认情况下, atd守护进程每60秒检查作业队列,有作业时,会检查作业运行时间,如果时间与当前时间四配，则运行此作业。at命令只执行一次。</p><p>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</p><p>检测当前进程有哪些：ps -ef</p><p>检测acd进程是否在运行：ps -ef | grep atd</p><p>命令格式：at 【选项】 【时间】，ctrl+d结束at命令输入</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-m</td><td>当指定的任务被完成后,将给用户发送邮件,即使没有标准输出</td></tr><tr><td>-I</td><td>atq（显示系统中待执行的任务列表）的别名</td></tr><tr><td>-d</td><td>atrm（删除待执行任务队列中的任务）的别名</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-q 队列</td><td>使用指定的队列</td></tr><tr><td>-f 文件</td><td>从指定文件读入任务而不是从标准输入读入</td></tr><tr><td>-t 时间参数</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table><h5 id="at指定时间方式"><a href="#at指定时间方式" class="headerlink" title="at指定时间方式"></a>at指定时间方式</h5><ol><li>hh:mm（小时：分钟）24小时制指定时间，若该时间已过，会到第二天执行</li><li>使用midnight (深夜)， noon (中午)， teatime (饮茶时间，一般是下午4点)等模糊词来指定时间</li><li>采用12小时计时制，在后面加上am (上午)或pm (下午)说明是上午还是下午</li><li>指定命令执行的具体日期，指定格式为month day(月日)或mm&#x2F;dd&#x2F;yy (月&#x2F;日&#x2F;年)或dd.mm.yy</li><li>使用相对计时法，如：now + 5 minutes</li><li>直接使用today、tomorrow指定完成命令的时间</li></ol><h6 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h6><p>一天后凌晨12点执行 &#x2F;bin&#x2F;ls home</p><p><img src="https://img-blog.csdnimg.cn/20210717194539556.png"></p><ul><li>统计&#x2F;opt下文件个数：<code>ls -l /opt | grep &quot;^-&quot; | wc -l</code>（^-是以-开头的文件，wc统计个数）</li><li>统计&#x2F;opt下目录个数：<code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></li><li>统计&#x2F;opt文件夹下文件的个数，包括子文件夹里的：<code>ls -lR /opt | grep &quot;^-&quot; | wc -l </code></li><li>统计&#x2F;opt文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code></li><li>以树状显示目录结构：<code>tree 目录</code>，注意默认是没有安装tree的，安装要root权限，安装tree命令：<code>yum install tree</code></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>使用<code>ps 【选项】</code>查看当前系统哪些进程在执行</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示当前终端的所有进程信息</td></tr><tr><td>-u</td><td>以用户的格式显示进程信息</td></tr><tr><td>-x</td><td>显示后天进程运行的参数</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>全格式</td></tr></tbody></table><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>kill 【选项】 进程号</p><p>killall 进程名称</p><p>常用选项：-9：强迫进程立即停止</p><h4 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h4><p>pstree 【选项】</p><p>常用选项</p><p>-p：显示进程的PID</p><p>-u：显示进程的所属用户</p><h4 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h4><p>service 服务名 [start|stop|restart|reload|status]</p><p>在CentOS7后很多服务不再使用service，而是systemctl</p><p>查看service指令管理的服务：ls -l &#x2F;etc&#x2F;init.d</p><h4 id="chkconfig指令"><a href="#chkconfig指令" class="headerlink" title="chkconfig指令"></a>chkconfig指令</h4><p>用于检查、设置系统的各种服务</p><p>查看服务：chkconfig –list [| grep xxx]</p><p>给服务在指定运行级别下设置开关：chkconfig –level 5 服务名 on&#x2F;off</p><h4 id="systemctl指令"><a href="#systemctl指令" class="headerlink" title="systemctl指令"></a>systemctl指令</h4><p>管理操作系统和服务的命令，是systemd（system daemon，操作系统服务管理器）交互的主要工具，实现的功能包含了service和chkconfig这两个命令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#例：查看当前防火墙的状况，关闭防火墙和启动防火墙</span><br><span class="line">1、systemctl status firewalld.service</span><br><span class="line">2、systemctl stop firewalld.service</span><br><span class="line">3、systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p><img src="https://s1.ax1x.com/2023/02/03/pSsnbKP.png"></p><p>防火墙开启时xshell访问linux需要打开22端口号，关闭后可以直接访问</p><h4 id="firewall指令"><a href="#firewall指令" class="headerlink" title="firewall指令"></a>firewall指令</h4><p>打开端口：firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</p><p>关闭端口：firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</p><p>重新载入才能生效：firewall-cmd –reload</p><p>查看所有开放端口：firewall-cmd –zone&#x3D;public –list-port</p><p>查询端口是否开放：firewall-cmd –query-port&#x3D;端口&#x2F;协议</p><h4 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h4><p>top与ps命令相似，用于显示正在执行的进程，top和ps最大的不同之处在于top在执行一段时间可以更新正在运行的进程</p><p>指令：top【选项】</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒速</td><td>指定top命令每隔几秒更新，默认3秒</td></tr><tr><td>-i</td><td>使top不显示任何闲置或僵死进程</td></tr><tr><td>-P</td><td>通过指定监控进程ID来仅仅监控某个进程的状态</td></tr></tbody></table><p>交互操作说明</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，从大到小，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序，从大到小</td></tr><tr><td>N</td><td>以PID排序，从大到小</td></tr><tr><td>Q或q</td><td>退出top</td></tr></tbody></table><h3 id="rpm和yum"><a href="#rpm和yum" class="headerlink" title="rpm和yum"></a>rpm和yum</h3><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4><p>用于下载包的打包及安装工具，它生成具有.rpm扩展名的文件，类似windows的setup.exe；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询所有安装rpm软件包：rpm -qa</span><br><span class="line">查询软件包是否安装：rpm -q 软件包名</span><br><span class="line">查询软件包信息：rpm -qi 软件包名</span><br><span class="line">查询软件包中的文件：rpm -ql 软件包名</span><br><span class="line">查询文件所属的软件包：rpm -qf 文件全路径名</span><br><span class="line">卸载软件包：rpm -e 软件包</span><br><span class="line">安装软件包：rpm -ivh 安装的全路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p>Shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p><p>查询yum服务器是否有需要安装的软件：yum list | grep xx软件列表</p><p>安装指定的yum包：yum install xx下载安装</p><h3 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a>Java环境安装</h3><h4 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h4><h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><ol><li><p>创建jdk文件夹：mkdir &#x2F;opt&#x2F;jdk</p></li><li><p>通过xftp传输Linux版本的jdk安装包到&#x2F;opt&#x2F;jdk目录下</p></li><li><p>进入jdk目录：cd &#x2F;opt&#x2F;jdk</p></li><li><p>解压jdk安装包：tar -zxvf jdk-8u261-linux-x64.tar.gz</p></li><li><p>创建java文件夹：mkdir &#x2F;usr&#x2F;local&#x2F;java</p></li><li><p>移动jdk安装文件：mv &#x2F;opt&#x2F;jdk&#x2F;jdk 1.8.0_261&#x2F; &#x2F;usr&#x2F;local&#x2F;java</p></li><li><p>配置环境变量：vim &#x2F;etc&#x2F;profile</p></li><li><p>在profile文末添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>让编辑过的环境变量生效：source &#x2F;etc&#x2F;profile</p></li></ol><h4 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h4><h5 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h5><ol><li>新建tomcat目录：mkdir &#x2F;opt&#x2F;tomcat</li><li>通过xftp传输Linux版本的tomcat安装包到&#x2F;opt&#x2F;tomcat目录下</li><li>进入tomcat目录：cd &#x2F;opt&#x2F;tomcat</li><li>解压tomcat：tar -zxvf apache-tomcat-8.5.69.tar.gz ，下载core核心包地址<a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></li><li>进入tomcat的bin目录：cd apache-tomcat-8.5.69&#x2F;bin，启动tomcat：.&#x2F;startup.sh</li><li>开放端口8080：firewall-cmd –permanent –add-port&#x3D;8080&#x2F;tcp</li><li>重新载入生效：firewall-cmd –reload</li><li>测试是否打开端口号：firewall-cmd –query-port&#x3D;8080&#x2F;tcp</li></ol><h4 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h4><h5 id="安装步骤-2"><a href="#安装步骤-2" class="headerlink" title="安装步骤"></a>安装步骤</h5><ol><li><p>新建mysql文件夹，进入：mkdir &#x2F;opt&#x2F;mysql</p></li><li><p>Xftp将安装包传输到&#x2F;opt&#x2F;tomcat目录下</p></li><li><p>进入mysql目录：cd &#x2F;opt&#x2F;mysql</p></li><li><p>解压mysql安装包：tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</p></li><li><p>查询mariadb： rpm -qa | grep mari。注意centos7.6自带的类mysql数据库是mariadb，会跟mysql冲突，要先删除</p></li><li><p>卸载mariadb：rpm -e –nodeps mariadb-libs ，rpm -e –nodeps marisa</p></li><li><p>开始安装mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>启动服务：systemctl start mysqld.service</p></li><li><p>开始设置root密码；Mysql自动给root用户设置随机密码，运行grep “password” &#x2F;var&#x2F;log&#x2F;mysqld.log可看到当前密码</p><p>运行mysql -u root -p，复制粘贴输入上述密码</p><p>修改密码</p><p>运行如下命令使密码生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><h4 id="Shell脚本执行方式"><a href="#Shell脚本执行方式" class="headerlink" title="Shell脚本执行方式"></a>Shell脚本执行方式</h4><h5 id="脚本格式要求"><a href="#脚本格式要求" class="headerlink" title="脚本格式要求"></a>脚本格式要求</h5><p>脚本以#!&#x2F;bin&#x2F;bash开头，需要可执行权限</p><h5 id="常用执行方式"><a href="#常用执行方式" class="headerlink" title="常用执行方式"></a>常用执行方式</h5><ol><li>输入脚本的绝对路径或相对路径（.&#x2F;xxx.sh）</li><li>sh+脚本</li></ol><h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><ol><li>定义变量：变量名&#x3D;值</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly 变量，静态变量不能unset</li><li>显示当前shell中所有变量：set</li><li>一般情况下var和{var}没有区别，但是用${}会较精确的界定变量名称的范围</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=`date`#运行反引号内的命令，将结果返回给变量A</span><br><span class="line">A=$(date)#等同于上面的语句</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="设置环境变量（全局变量）"><a href="#设置环境变量（全局变量）" class="headerlink" title="设置环境变量（全局变量）"></a>设置环境变量（全局变量）</h5><p>export 变量名&#x3D;变量值（将shell变量输出为环境变量）</p><p>source 配置文件（让修改后的配置信息立即生效）</p><p>echo $变量名（查询环境变量的值）</p><h6 id="shell注释"><a href="#shell注释" class="headerlink" title="shell注释"></a>shell注释</h6><ul><li><p>单行注释：通过一个’#’实现，开始部分的#不是用于注释的</p></li><li><p>多行注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;xxxx</span><br><span class="line">注释内容</span><br><span class="line">xxxx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>xxxx可以为任意字符串，中间部分为注释</p></li></ul><h5 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h5><p>用于在执行脚本时获取命令行的参数信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$n#n为数字，表示第几个参数，10以上需要用大括号如$&#123;10&#125;</span><br><span class="line">$*#命令行所有参数，将所有参数当做一个整体</span><br><span class="line">$@#命令行所有参数，将每个参数分别输出</span><br><span class="line">$##命令行中所有参数的个数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h5><p>事先定义好的变量，直接在脚本中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$#当前进程的进程号PID</span><br><span class="line">$!#后台运行的最后一个进程的进程号PID</span><br><span class="line">$?#最后一次执行命令的返回状态；若为0则表示正确执行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$((表达式))或$[表达式]或expr m+n</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断 ]</span><br><span class="line">then</span><br><span class="line">代码</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#若输入参数大于等于60则输出及格了，若小于60则输出不及格</span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">echo&quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">echo&quot;不及格&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo&quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo&quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo&quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">echo&quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1]</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo&quot;结果=$SUM&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h4><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><p>read [选项] [参数]</p><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>-p：指定读取值时的提示符；</p><p>-t：指定读取值时等待的时间；</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>变量：指定读取值的变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#案例1：读取控制台输入一个num1值</span><br><span class="line">read -p &quot;请输入指定的num1=&quot; NUM1</span><br><span class="line">echo &quot;输入的num1=$NUM1&quot;</span><br><span class="line">#案例2：读取控制台输入一个num2值，在5秒内输入</span><br><span class="line">read -t 5 -p &quot;请输入num2=&quot; NUM2</span><br><span class="line">echo &quot;输入的num2=$NUM2&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h5><p>返回一个字符串参数的基本文件名称</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>basename String [ Suffix ]</p><h6 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h6><p>读取String参数，删除以&#x2F;结尾的前缀及任何指定的Suffix参数，并将剩余基本文件名称写至标准输出</p><ol><li><p>若String包含的都是斜杠字符，则将字符串更改为单个&#x2F;</p></li><li><p>若指定Suffix参数和剩余字符相同，则不修改此字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basename /u/dee/desktop/cns.boo cns.boo=&gt;cns.boo</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若只与字符串的后缀相同，则除去指定后缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basename /u/dee/desktop/cns.boo .boo=&gt;cns</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h6 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h6><ol><li><p>显示一个shell变量的基本名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basename $WORKFILE</span><br><span class="line">#显示WORKFILE值的基本名称，若WORKFILE变量值是/home/jim/program.c文件，则此命令显示program.c </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>构造一个和另一个文件名称相同（除了后缀）的文件名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OFILE=`basename $1 .c`.o</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h5><p>获取某个文件或目录的上一级目录</p><h6 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dirname /home/users/aoquan/</span><br><span class="line">#输出结果：/home/users</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><h6 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#案例：计算输入两个参数的和，getSum</span><br><span class="line">function getSum()&#123;</span><br><span class="line">        sum=$[$n1+$n2]</span><br><span class="line">        echo &quot;和是=$sum&quot;</span><br><span class="line">&#125;</span><br><span class="line">#输入两个值</span><br><span class="line">read -p &quot;第一个值=&quot; n1</span><br><span class="line">read -p &quot;第二个值=&quot; n2</span><br><span class="line">#调用函数</span><br><span class="line">getSum $n1 $n2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据备份案例"><a href="#数据备份案例" class="headerlink" title="数据备份案例"></a>数据备份案例</h4><h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><p>每天凌晨2:30备份数据库smile到&#x2F;data&#x2F;backup&#x2F;db；备份开始和结束给出相应的提示信息；备份文件以备份时间为文件名，并打包成.tar.gz形式；在备份的同时检查是否有7天前备份的数据库文件，若有就将其删除</p><p><code>vim /usr/sbin/mysql_db_backup.sh 内容如下</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份目录</span></span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前时间</span></span><br><span class="line">DATATIME=$(date + %Y-%m-%d_%H%M%S)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库地址</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库密码</span></span><br><span class="line">DB_PW=root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份的数据库名</span></span><br><span class="line">DATABASE=smile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若备份目录不存在则创建</span></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATATIME&#125;&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份数据库</span></span><br><span class="line">echo &quot;开始备份数据库$&#123;DATABASE&#125;&quot;</span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATATIME&#125;/$DATATIME.sql.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将备份文件夹处理成.tar.gz的格式</span></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATATIME.tar.gz $&#123;DATATIME&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除对应的备份目录</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$&#123;DATATIME&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除7天前的备份</span></span><br><span class="line">find $&#123;BACKUP&#125; -atime +7 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;备份数据库$&#123;DATABASE&#125;成功&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>定时脚本</code></p><p><code>命令行敲crontab -e ，接着输入如下内容</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * * /usr/sbin/mysql_db_backup.sh</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="系统常用日志"><a href="#系统常用日志" class="headerlink" title="系统常用日志"></a>系统常用日志</h4><table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;boot.log</font></td><td>系统启动日志</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;cron</font></td><td>记录与系统定时任务相关的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;cups&#x2F;</td><td>记录打印信息的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;dmesg</td><td>记录系统开机时自检信息，可以使用dmesg命令查看内核自检信息</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;btmp</td><td>记录错误登录的日志，该日志为二进制文件，不能用vi查看，要使用lastb命令查看</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;lasllog</font></td><td>记录系统所有用户最后一次登录时间的日志，也只能使用lastlog命令查看</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;mailog</font></td><td>记录邮件信息的日志</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;message</font></td><td>记录系统重要消息的日志，若系统出现问题，首先应该检查的就是该日志文件</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;secure</font></td><td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，如系统的登录、ssh的登录、sudo授权</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;wtmp</td><td>永久记录所有用户的登录、注销信息、同时记录系统的启动、重启、关机事件，只能使用lastb命令查看</td></tr><tr><td><font color=red>&#x2F;var&#x2F;log&#x2F;ulmp</font></td><td>记录当前已登录用户的信息，随着用户的登录和注销不断变化，使用w、who、users等命令查看</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go基础</title>
      <link href="/go%E5%9F%BA%E7%A1%80/"/>
      <url>/go%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>由一串固定长度的字符连接起来的字符序列，Go的字符串是由单个UTF-8表示的字节连接起来的，由于该编码的不定性，字符串可能根据需要占用1~4byte；即字符串是字节的定长数组</p><p>字符串为不可变类型，故不能直接修改字符串的内容，如需修改，需要将字符串内容复制到一个可写的变量中（一般是<code>[]byte</code>或<code>[]rune</code>），然后进行修改</p><h3 id="字符串的转义"><a href="#字符串的转义" class="headerlink" title="字符串的转义"></a>字符串的转义</h3><ul><li>双引号创建可解析的字符串，支持转义，但不能用来引用多行</li><li>反引号创建原生的字符串字面量，可由多行组成，不支持转义，且可包含除反引号外的所有字符</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&quot;\&quot;Go web\&quot;,I love you \n&quot;</span></span><br><span class="line">str2 := <span class="string">`&quot;Go web&quot;,</span></span><br><span class="line"><span class="string">I love you \n`</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Go web&quot;</span>,I love you</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Go web&quot;</span>,</span><br><span class="line">I love you \n</span><br></pre></td></tr></table></figure><h3 id="字符串的修改"><a href="#字符串的修改" class="headerlink" title="字符串的修改"></a>字符串的修改</h3><ul><li><p>修改字节（用[]byte）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hi 世界!&quot;</span></span><br><span class="line">by := []<span class="type">byte</span>(str)</span><br><span class="line">by[<span class="number">2</span>] = <span class="string">&#x27;,&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Hi,世界</span></span><br></pre></td></tr></table></figure></li><li><p>修改字符（用[]rune）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;Hi 世界&quot;</span></span><br><span class="line">by := []<span class="type">rune</span>(str)</span><br><span class="line">by[<span class="number">3</span>] = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">by[<span class="number">4</span>] = <span class="string">&#x27;国&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Hi 中国</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 中有三种类型的函数。函数参数、返回值以及它们的类型被统称为函数签名：  </p><ul><li>普通的带有名字的函数</li><li>匿名函数或者lambda函数</li><li>方法（Methods）</li></ul><p>这样是不正确的 Go 代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它必须是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>允许多个同名函数，只要它们拥有不同的形参&#x2F;或者不同的返回值；这在 Go 中是不被允许的</p><p>函数值之间可以比较：若引用的是相同函数或都是 <code>nil</code> ，则认为是相同的函数</p><h3 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h3><p>任何一个有返回值（单个或多个）的函数都必须以 <code>return</code> 或 <code>panic</code>结尾</p><p>在函数调用时，切片 (slice)、字典 (map)、接口 (interface)、通道 (channel) 这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）</p><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>命名返回值作为结果形参被初始化为相应类型的零值，当需要返回的时候，我们只需要一条简单的不带参数的 <code>return</code> 语句，即使只有一个命名返回值也需用括号括起来；当有多个非命名返回值时需用括号括起来，如<code>(int,int)</code>，任何一个非命名返回值在<code>return</code>中都要指出返回值变量或是一个可计算的值</p><h4 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h4><p>若变长参数的类型并不都相同时的传递方法：</p><ol><li><p>定义一个结构类型，假设它叫 <code>Options</code>，用以存储所有可能的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">par1 type1,</span><br><span class="line">par2 type2,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>F1()</code> 可以使用正常的参数 <code>a</code> 和 <code>b</code>，以及一个没有任何初始化的 <code>Options</code> 结构： <code>F1(a, b, Options &#123;&#125;)</code>。如果需要对选项进行初始化，则可以使用 <code>F1(a, b, Options &#123;par1:val1, par2:val2&#125;)</code></p></li><li><p>使用空接口：</p><p>若一个变长参数的类型没有被指定，则可以使用默认的空接口<code>interface&#123;&#125;</code>，该方案不仅可以用于长度未知的参数，还可以用于任何不确定类型的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck</span><span class="params">(..,..,values … <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">switch</span> v := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>: …</span><br><span class="line"><span class="keyword">case</span> float: …</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>: …</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>: …</span><br><span class="line"><span class="keyword">default</span>: …</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="defer和追踪"><a href="#defer和追踪" class="headerlink" title="defer和追踪"></a>defer和追踪</h3><p>关键字 <code>defer</code> 允许我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数；且<code>defer</code>允许我们进行一些函数执行完成后的收尾工作</p><p>当有多个 <code>defer</code> 行为被注册时，它们会以逆序执行（类似栈，即后进先出）</p><h4 id="使用defer实现代码追踪"><a href="#使用defer实现代码追踪" class="headerlink" title="使用defer实现代码追踪"></a>使用<code>defer</code>实现代码追踪</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;entering:&quot;</span>, s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;leaving:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> un(trace(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;in a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> un(trace(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">fmt.Println(<span class="string">&quot;in b&quot;</span>)</span><br><span class="line">a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure><h4 id="使用-defer-语句记录函数的参数与返回值"><a href="#使用-defer-语句记录函数的参数与返回值" class="headerlink" title="使用 defer 语句记录函数的参数与返回值"></a>使用 <code>defer</code> 语句记录函数的参数与返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;func1(%q) = %d, %v&quot;</span>, s, n, err)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">7</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">func1(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output: 2011/10/04 10:46:11 func1(&quot;Go&quot;) = 7, EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>close()</code></td><td>用于管道通信</td></tr><tr><td><code>len()</code>、<code>cap()</code></td><td><code>len()</code> 用于返回某类型的长度或数量（字符串、数组、切片、<code>map</code> 和管道）；<code>cap()</code> 用于返回某个类型的最大容量（只能用于数组、切片和管道，不能用于 <code>map</code>）</td></tr><tr><td><code>new()</code>、<code>make()</code></td><td>分配内存，<code>new()</code> 值类型和自定义类型，<code>make</code> 内置引用类型（切片、<code>map</code> 和管道）</td></tr><tr><td><code>copy()</code>、<code>append()</code></td><td>用于复制和连接切片</td></tr><tr><td><code>panic()</code>、<code>recover()</code></td><td>均用于错误处理机制</td></tr><tr><td><code>print()</code>、<code>println()</code></td><td>底层打印函数，在部署环境中建议使用<code>fmt</code>包</td></tr><tr><td><code>complex()</code>、<code>real ()</code>、<code>imag()</code></td><td>用于创建和操作复数</td></tr></tbody></table><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>可以将匿名函数赋值给变量，即保存函数的地址到变量中，然后通过变量名对函数进行调用，也可以直接对匿名函数进行调用，匿名函数也被称为闭包：</p><p><code>func(x, y int) int &#123; return x + y &#125; (3, 4)</code></p><h4 id="应用闭包：将参数作为返回值"><a href="#应用闭包：将参数作为返回值" class="headerlink" title="应用闭包：将参数作为返回值"></a>应用闭包：将参数作为返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = Adder()</span><br><span class="line">    fmt.Print(f(<span class="number">1</span>),<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    fmt.Print(f(<span class="number">20</span>),<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    fmt.Print(f(<span class="number">300</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(delta <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x += delta</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//1 - 21 - 321</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量</p><h5 id="实例：工厂函数"><a href="#实例：工厂函数" class="headerlink" title="实例：工厂函数"></a>实例：工厂函数</h5><p>一个返回值为另一个函数的函数；在创建一系列相似函数时非常有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeAddSuffix</span><span class="params">(suffix <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addBmp := MakeAddSuffix(<span class="string">&quot;.bmp&quot;</span>)</span><br><span class="line">addJpeg := MakeAddSuffix(<span class="string">&quot;.jpeg&quot;</span>)</span><br><span class="line">addBmp(<span class="string">&quot;file&quot;</span>) <span class="comment">// returns: file.bmp</span></span><br><span class="line">addJpeg(<span class="string">&quot;file&quot;</span>) <span class="comment">// returns: file.jpeg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h4><p>在分析和调试复杂的程序时，无数个函数在不同的代码文件中相互调用，如果这时候能够准确地知道哪个文件中的具体哪个函数正在执行，对于调试是十分有帮助的；包 <code>runtime</code> 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">where := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _,file,line,_ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    log.Printf(<span class="string">&quot;%s:%d&quot;</span>,file,line)</span><br><span class="line">&#125;</span><br><span class="line">where()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过内存缓存提升性能"><a href="#通过内存缓存提升性能" class="headerlink" title="通过内存缓存提升性能"></a>通过内存缓存提升性能</h4><p>在大量计算时，提升性能最直接有效的方式即避免重复计算，在缓存重复利用相同计算的结果称为内存缓存</p><p>如斐波那契数列，要计算数列中第 n 个数字，需要先得到之前两个数的值，但很明显绝大多数情况下前两个数的值都是已经计算过的，此时将第 n 个数的值存在数组中索引为 n 的位置</p><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是具有相同 <strong>唯一类型</strong> 的一组已编号且长度固定的数据项序列，声明格式为：</p><p><code>var arr1 [5]int</code></p><p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定</p><p>go数组是值类型，可通过<code>new()</code>创建：<code>var arr1 = new([5]int)</code>，故在函数中作为参数传入时不修改原始数组，若想修改，则需使用<code>&amp;</code>操作符以引用方式传入</p><p>该种方式和 <code>var arr2 [5]int</code> 的区别是：<code>arr1</code> 的类型是 <code>*[5]int</code>，而 <code>arr2</code> 的类型是 <code>[5]int</code>；这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2 := *arr1</span><br><span class="line">arr2[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">//这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片提供了计算容量的函数 <code>cap()</code> 可以测量切片最长可以达到多少：切片的长度 + 数组除切片之外的长度。若<code>s</code> 是一个切片，<code>cap(s)</code> 就是从 <code>s[0]</code> 到数组末尾的数组长度：<code>0 &lt;= len(s) &lt;= cap(s)</code></p><p>slice由三个部分构成：指针、长度和容量</p><p>slice不能直接用<code>==</code>进行比较，对于字节型slice可以使用<code>bytes.Equal</code>函数判断是否相等，对于其它类型需要展开每个元素比较（slice允许与nil比较）</p><p>一个nil值的slice的行为和其它任意0长度的slice一样；若需要判断一个slice是否为空，需要使用len(s) &#x3D;&#x3D; 0 判断，不应该使用s &#x3D;&#x3D; nil</p><p>可以将 <code>s2</code> 向后移动一位 <code>s2 = s2[1:]</code>，但是<code>s2 = s2[-1:]</code> 会导致编译错误，切片不能被重新分片获取数组的前一个元素</p><h4 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h4><p>当相关数组未定义时，可以用 <code>make()</code> 创建切片，同时创建好相关数组：<code>var slice1 []type = make([]type, len)</code>；可以简写为<code>slice1 := make([]type,len)</code>，<code>len</code>是数组的长度且是<code>slice</code>的初始长度</p><p>故定义<code>s2 := make([]int,10)</code>，则<code>cap(s2)==len(s2)==10</code></p><p>若想创建一个 <code>slice1</code>不占用整个数组，只占用以 <code>len</code> 为个数个项，那么只要：<code>slice1 := make([]type, len, cap)</code></p><p><code>make()</code> 的使用方式是：<code>func make([]T, len, cap)</code>，其中 <code>cap</code> 是可选参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="type">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br></pre></td></tr></table></figure><h4 id="切片的扩容"><a href="#切片的扩容" class="headerlink" title="切片的扩容"></a>切片的扩容</h4><h5 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type,old slice,<span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap/<span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="扩容原理"><a href="#扩容原理" class="headerlink" title="扩容原理"></a>扩容原理</h5><ul><li>当前所需容量（cap）大于原容量两倍（doublecap），则最终申请容量（newcap）为当前所需容量（cap）</li><li>若不大于原容量两倍时<ol><li>原切片长度小于1024则申请原容量的两倍</li><li>否则，最终申请容量（newcap，初始值等于 old.cap）每次增加newcap&#x2F;4，直到大于所需容量（cap）为止，然后判断最终容量是否溢出，若溢出，最终申请容量等于所需容量</li></ol></li></ul><h6 id="go切片扩容为什么是2倍"><a href="#go切片扩容为什么是2倍" class="headerlink" title="go切片扩容为什么是2倍"></a>go切片扩容为什么是2倍</h6><ol><li><p>确定切片的大致容量</p></li><li><p>根据元素所占字节大小，最终确定容量</p><p>当元素所占字节大小为1、8或2的倍数时，会执行内存对齐操作</p></li></ol><h4 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h4><p>Go 的多维切片可以任意切分，而且，内层的切片必须以循环等方式单独分配</p><h4 id="切片重组"><a href="#切片重组" class="headerlink" title="切片重组"></a>切片重组</h4><p>在切片达到容量上限后扩容改变切片长度的过程</p><h4 id="切片的复制与追加"><a href="#切片的复制与追加" class="headerlink" title="切片的复制与追加"></a>切片的复制与追加</h4><p>如果想增加切片的容量，必须创建一个更大的切片并把原分片的内容都拷贝过来，可使用<code>copy()</code>和<code>append()</code>函数，追加的元素必须和原切片元素是同类型</p><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>如果 <code>s</code> 的容量不足以存储新增元素，<code>append()</code> 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组，<code>append()</code> 方法总是返回成功，除非系统内存耗尽</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendByte</span><span class="params">(slice []<span class="type">byte</span>, data ...<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(slice)</span><br><span class="line">    n := m + <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="built_in">cap</span>(slice) &#123;</span><br><span class="line">        newSlice := <span class="built_in">make</span>([]<span class="type">byte</span>,(n+<span class="number">1</span>)*<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">copy</span>(newSlice,slice)</span><br><span class="line">        slice = newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    slice = slice[<span class="number">0</span>:n]</span><br><span class="line">    <span class="built_in">copy</span>(slice[m:n],data)</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="append常见操作"><a href="#append常见操作" class="headerlink" title="append常见操作"></a>append常见操作</h6><ol><li><p>将切片 <code>b</code> 的元素追加到切片 <code>a</code> 之后：<code>a = append(a, b...)</code></p></li><li><p>复制切片 <code>a</code> 的元素到新的切片 <code>b</code> 上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>删除位于索引 <code>i</code> 的元素：<code>a = append(a[:i], a[i+1:]...)</code></p></li><li><p>切除切片 <code>a</code> 中从索引 <code>i</code> 至 <code>j</code> 位置的元素：<code>a = append(a[:i], a[j:]...)</code></p></li><li><p>为切片 <code>a</code> 扩展 <code>j</code> 个元素长度：<code>a = append(a, make([]T, j)...)</code></p></li><li><p>在索引 <code>i</code> 的位置插入元素 <code>x</code>：<code>a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</code></p></li><li><p>在索引 <code>i</code> 的位置插入长度为 <code>j</code> 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></p></li><li><p>在索引 <code>i</code> 的位置插入切片 <code>b</code> 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></p></li><li><p>取出位于切片 <code>a</code> 最末尾的元素 <code>x</code>：<code>x, a = a[len(a)-1], a[:len(a)-1]</code></p></li><li><p>将元素 <code>x</code> 追加到切片 <code>a</code>：<code>a = append(a, x)</code></p></li></ol><h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p><code>func copy(dst, src []T) int</code> 方法将类型为 <code>T</code> 的切片从源地址 <code>src</code> 拷贝到目标地址 <code>dst</code>，覆盖 <code>dst</code> 的相关元素，并且返回拷贝的元素个数。源地址和目标地址可能会有重叠。拷贝个数是 <code>src</code> 和 <code>dst</code> 的长度最小值。若 <code>src</code> 是字符串则元素类型就是 <code>byte</code>。若还想继续使用 <code>src</code>，在拷贝结束后执行 <code>src = dst</code></p><h4 id="字符串生成字节切片"><a href="#字符串生成字节切片" class="headerlink" title="字符串生成字节切片"></a>字符串生成字节切片</h4><p>可以通过<code>c := []byte(s)</code>获取一个字节的切片<code>c</code>，还可以通过 <code>copy()</code> 函数来达到相同的目的：<code>copy(dst []byte, src string)</code></p><p>将一个字符串追加到某一个字节切片的尾部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">b = <span class="built_in">append</span>(b, s...)</span><br></pre></td></tr></table></figure><h4 id="字符串和切片的内存结构"><a href="#字符串和切片的内存结构" class="headerlink" title="字符串和切片的内存结构"></a>字符串和切片的内存结构</h4><p>在内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。因为指针对用户来说是完全不可见，因此我们可以依旧把字符串看做是一个值类型，也就是一个字符数组</p><p>字符串 <code>string s = &quot;hello&quot;</code> 和子字符串 <code>t = s[2:3]</code> 在内存中的结构可以用下图表示：</p><img src="https://s1.ax1x.com/2023/03/09/ppmHohn.png" style="zoom:50%"/><h4 id="修改字符串的某个字符"><a href="#修改字符串的某个字符" class="headerlink" title="修改字符串的某个字符"></a>修改字符串的某个字符</h4><p>Go 中字符串不可变，即 <code>str[index]</code> 这样的表达式是不可以被放在等号左侧的</p><p>因此必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)<span class="comment">//s2 == &quot;cello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字节数组对比函数"><a href="#字节数组对比函数" class="headerlink" title="字节数组对比函数"></a>字节数组对比函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b[]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组的长度可能不同</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 数组相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="搜索及排序切片和数组"><a href="#搜索及排序切片和数组" class="headerlink" title="搜索及排序切片和数组"></a>搜索及排序切片和数组</h4><p>标准库提供了 <code>sort</code> 包实现常见的搜索和排序操作。可以使用 <code>sort</code> 包中的函数 <code>func Ints(a []int)</code> 实现对 <code>int</code> 类型的切片排序。例如 <code>sort.Ints(arri)</code>，其中变量 <code>arri</code> 就是需要被升序排序的数组或切片。为了检查某个数组是否已经被排序，可通过函数 <code>IntsAreSorted(a []int) bool</code> 检查，若返回 <code>true</code> 则表示已经被排序</p><p>类似的，可以使用函数 <code>func Float64s(a []float64)</code> 来排序 <code>float64</code> 的元素，或使用函数 <code>func Strings(a []string)</code> 排序字符串元素</p><p>想要在数组或切片中搜索一个元素，该数组或切片必须先被排序（因为标准库的搜索算法使用的是二分法）。使用函数 <code>func SearchInts(a []int, n int) int</code> 进行搜索，并返回对应结果的索引值</p><p>当然，还可以搜索 <code>float64</code> 和字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="type">float64</span>, x <span class="type">float64</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="type">string</span>, x <span class="type">string</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h4><p>只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存</p><p><strong>示例</strong> 函数 <code>FindDigits()</code> 将一个文件加载到内存，然后搜索其中所有的数字并返回一个切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">&quot;[0-9]+&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码可以顺利运行，但返回的 <code>[]byte</code> 指向的底层是整个文件的数据。只要该返回的切片不被释放，垃圾回收器就不能释放整个文件所占用的内存。换句话说，一点点有用的数据却占用了整个文件的内存。</p><p>想要避免这个问题，可以通过拷贝我们需要的部分到一个新的切片中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   b, _ := ioutil.ReadFile(filename)</span><br><span class="line">   b = digitRegexp.Find(b)</span><br><span class="line">   c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">   <span class="built_in">copy</span>(c, b)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>事实上，上面这段代码只能找到第一个匹配正则表达式的数字串。要想找到所有的数字，可以尝试下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindFileDigits</span><span class="params">(filename <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   fileBytes, _ := ioutil.ReadFile(filename)</span><br><span class="line">   b := digitRegexp.FindAll(fileBytes, <span class="built_in">len</span>(fileBytes))</span><br><span class="line">   c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _, bytes := <span class="keyword">range</span> b &#123;</span><br><span class="line">      c = <span class="built_in">append</span>(c, bytes...)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h4><p>可以应用于数组和切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, value := <span class="keyword">range</span> slice1 &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一个返回值 <code>ix</code> 是数组或者切片的索引，第二个是在该索引位置的值</p><p><code>value</code> 只是 <code>slice1</code> 某个索引位置的值的一个拷贝，不能用来修改 <code>slice1</code> 该索引位置的值</p><h4 id="new-和make-的区别"><a href="#new-和make-的区别" class="headerlink" title="new()和make()的区别"></a>new()和make()的区别</h4><p>两者都在堆上分配内存，但它们的行为不同，适用于不同类型</p><ul><li><code>new(T)</code> 为每个新类型 <code>T</code> 分配一片内存，初始化为 <code>0</code> 并且返回类型为 <code>*T</code> 的内存地址：这种方法 <strong>返回一个指向类型为 <code>T</code>，值为 <code>0</code> 的地址的指针</strong>，它适用于值类型如数组和结构体，相当于 <code>&amp;T&#123;&#125;</code></li><li><code>make(T)</code> <strong>返回一个类型为 T 的初始值</strong>，它只适用于 3 种内建的引用类型：切片、<code>map</code> 和 <code>channel</code></li></ul><p>即<code>new()</code>分配内存，<code>make()</code>初始化，如下图所示：</p><img src="https://s1.ax1x.com/2023/03/09/ppm4rY6.png" style="zoom:50%"/><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="键值对元素"><a href="#键值对元素" class="headerlink" title="键值对元素"></a>键值对元素</h3><p><code>val1,isPresent = map1[key1]</code></p><p><code>isPresent</code>返回一个<code>bool</code>值：若 <code>key1</code> 存在于 <code>map1</code>，<code>val1</code> 就是 <code>key1</code> 对应的 <code>value</code> 值，并且 <code>isPresent</code> 为 <code>true</code>；若<code>key1</code> 不存在，<code>val1</code> 就是一个空值，且 <code>isPresent</code> 返回 <code>false</code></p><p>判断某个<code>key</code>是否存在的常规方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := map1[key1]; ok &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>map1</code>中删除<code>key1</code>：<code>delete(map1,key1)</code>；若<code>key1</code>不存在不会产生错误</p><p> <code>map</code> 不是按照 key 的顺序排列的，也不是按照 value 的序排列的</p><blockquote><p>map 的本质是散列表，而 map 的增长扩容会导致重新进行散列，这就可能使 map 的遍历结果在扩容前后变得不可靠，Go 设计者为了让大家不依赖遍历的顺序，每次遍历的起点–即起始 bucket 的位置不一样，即不让遍历都从某个固定的 bucket0 开始，所以即使未扩容时我们遍历出来的 map 也总是无序的</p></blockquote><h3 id="map类型的切片"><a href="#map类型的切片" class="headerlink" title="map类型的切片"></a>map类型的切片</h3><p>获取一个 <code>map</code> 类型的切片，必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中每个 <code>map</code> 元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> items &#123;</span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Version A: Value of items: %v\n&quot;</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This &#x27;item&#x27; will be lost on the next iteration.</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Version B: Value of items: %v\n&quot;</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]]</span><br><span class="line">Version B: Value of items: [map[] map[] map[] map[] map[]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> A 通过索引使用切片的 <code>map</code> 元素。 B 中获得的项只是 <code>map</code> 值的一个拷贝，所以真正的 <code>map</code> 元素没有得到初始化</p><h3 id="将map的键值对调"><a href="#将map的键值对调" class="headerlink" title="将map的键值对调"></a>将map的键值对调</h3><p>若<code>map</code>的值类型可以作为key且所有value是唯一的，则可通过下面的方法对调：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">barVal = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">34</span>, <span class="string">&quot;bravo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;charlie&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;delta&quot;</span>: <span class="number">87</span>, <span class="string">&quot;echo&quot;</span>: <span class="number">56</span>, <span class="string">&quot;foxtrot&quot;</span>: <span class="number">12</span>,</span><br><span class="line"><span class="string">&quot;golf&quot;</span>: <span class="number">34</span>, <span class="string">&quot;hotel&quot;</span>: <span class="number">16</span>, <span class="string">&quot;indio&quot;</span>: <span class="number">87</span>,</span><br><span class="line"><span class="string">&quot;juliet&quot;</span>: <span class="number">65</span>, <span class="string">&quot;kili&quot;</span>: <span class="number">43</span>, <span class="string">&quot;lima&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">invMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">invMap[v] = k</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;inverted:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> invMap &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Key: %v, Value: %v / &quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>将创建对象的具体过程屏蔽隔离；由工厂创建不同种类的对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd      <span class="type">int</span>     <span class="comment">// 文件描述符</span></span><br><span class="line">    name    <span class="type">string</span>  <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="type">int</span>, name <span class="type">string</span>)</span></span> *File &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := NewFile(<span class="number">10</span>, <span class="string">&quot;./test.txt&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若 <code>File</code> 是一个结构体类型，则 <code>new(File)</code> 和 <code>&amp;File&#123;&#125;</code> 是等价的</p><h4 id="强制使用工厂方法"><a href="#强制使用工厂方法" class="headerlink" title="强制使用工厂方法"></a>强制使用工厂方法</h4><h5 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h5><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，则这种形式的标识符的对象就可以被外部包的代码所使用（像面向对象语言中的 public）</p><p>标识符若以小写字母开头，则对包外不可见，但在包的内部是可见并且可用的（像面向对象语言中的 private ）</p><p>当使用 <code>.</code> 作为包的别名时，可以不通过包名来使用：<code>import . &quot;./pack1&quot;</code></p><p><code>import _ &quot;./pack1/pack1&quot;</code>，<code>pack1</code> 包只执行它的 <code>init()</code> 函数并初始化其中的全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> matrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMatrix</span><span class="params">(params)</span></span> *matrix &#123;</span><br><span class="line">    m := <span class="built_in">new</span>(matrix) <span class="comment">// 初始化 m</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在其他包中使用工厂方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;matrix&quot;</span></span><br><span class="line">...</span><br><span class="line">wrong := <span class="built_in">new</span>(matrix.matrix)     <span class="comment">// 编译失败（matrix 是私有的）</span></span><br><span class="line">right := matrix.NewMatrix(...)  <span class="comment">// 实例化 matrix 的唯一方式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内嵌结构体和匿名字段"><a href="#内嵌结构体和匿名字段" class="headerlink" title="内嵌结构体和匿名字段"></a>内嵌结构体和匿名字段</h3><p>结构体可以包含一个或多个 匿名（或内嵌）字段，只有字段的类型是必须的，此时类型就是字段的名字，因此每种数据类型只能有一个匿名字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">in1 <span class="type">int</span></span><br><span class="line">in2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">b    <span class="type">int</span></span><br><span class="line">c    <span class="type">float32</span></span><br><span class="line"><span class="type">int</span>  <span class="comment">// anonymous field</span></span><br><span class="line">innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">outer := <span class="built_in">new</span>(outerS)</span><br><span class="line">outer.b = <span class="number">6</span></span><br><span class="line">outer.c = <span class="number">7.5</span></span><br><span class="line">outer.<span class="type">int</span> = <span class="number">60</span></span><br><span class="line">outer.in1 = <span class="number">5</span></span><br><span class="line">outer.in2 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;outer.b is: %d\n&quot;</span>, outer.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;outer.c is: %f\n&quot;</span>, outer.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;outer.int is: %d\n&quot;</span>, outer.<span class="type">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;outer.in1 is: %d\n&quot;</span>, outer.in1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;outer.in2 is: %d\n&quot;</span>, outer.in2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构体字面量</span></span><br><span class="line">outer2 := outerS&#123;<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">60</span>, innerS&#123;<span class="number">5</span>, <span class="number">10</span>&#125;&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;outer2 is:&quot;</span>, outer2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h4><p>当两个字段拥有相同的名字（可能是继承来的名字）时：</p><ol><li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式</li><li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;a <span class="type">int</span>&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;a, b <span class="type">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;A; B&#125;</span><br><span class="line"><span class="keyword">var</span> c C</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D <span class="keyword">struct</span> &#123;B; b <span class="type">float32</span>&#125;</span><br><span class="line"><span class="keyword">var</span> d D</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时使用<code>c.a</code>是错误的；使用<code>d.b</code>没有问题</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>类型无需显示声明实现了某个接口，接口可以被隐式地实现，多个类型可以实现同一接口</li><li>实现某个接口的类型（除了实现接口方法外）可以有其他的方法</li><li>一个类型可以实现多个接口</li><li>接口类型可以包含一个实例的引用，该实例类型实现了此接口（接口是动态类型）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">Area() <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">side <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span></span> Area() <span class="type">float32</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">areaIntf = sq1</span><br><span class="line"><span class="comment">// shorter,without separate declaration:</span></span><br><span class="line"><span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line"><span class="comment">// or even:</span></span><br><span class="line"><span class="comment">// areaIntf := sq1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The square has area: %f\n&quot;</span>, areaIntf.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//The square has area: 25.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述实例中创建了一个<code>Square</code>的实例，且在主程序外定义了一个接受者类型是<code>Square</code>的<code>Area()</code>：结构体<code>Square</code>实现了接口<code>Shaper</code> </p><p>故可将一个 <code>Square</code> 类型的变量赋值给一个接口类型的变量：<code>areaIntf = sq1</code> </p><p>现在接口变量包含一个指向 <code>Square</code> 变量的引用，通过它可以调用 <code>Square</code> 上的方法 <code>Area()</code>；接口变量里包含了接收者实例的值和指向对应方法表的指针；<strong>这是多态的Go版本</strong></p><p>如果 <code>Shaper</code> 有另外一个方法 <code>Perimeter()</code>，但是 <code>Square</code> 没有实现它，即使没有在 <code>Square</code> 实例上调用这个方法，编译器会给出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cannot use sq1 (type *Square) as type Shaper in assignment:</span><br><span class="line">*Square does not implement Shaper (missing Area method)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，相当于直接将这些内嵌接口的方法列举在外层接口中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型；语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value,ok := x.(T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）</p><p>该断言表达式会返回 x 的值（ value）和一个布尔值（ ok），可根据该布尔值判断 x 是否为 T 类型：</p><ul><li>若T是具体某个类型，则检查x的动态类型是否等于具体类型T；若成功，则返回x的动态值，类型为T</li><li>若T 是接口类型，检查 x 的动态类型是否满足 T；若成功，x 的动态值不被提取，返回一个类型为 T 的接口值</li><li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败</li></ul><p>通过类型断言可以做到：</p><ul><li>检查<code>i</code>是否为<code>nil</code></li><li>检查<code>i</code>存储的值是否为某个类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">t1 := i.(<span class="type">int</span>)</span><br><span class="line">fmt.Println(t1)</span><br><span class="line">fmt.Println(<span class="string">&quot;====分隔线====&quot;</span>)</span><br><span class="line">t2 := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(t2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">=====分隔线=====</span><br><span class="line">panic: interface conversion: interface &#123;&#125; is int, not string</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">E:/GoPlayer/src/main.go:12 +0x10e</span><br><span class="line">exit status 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is a bool\n&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is a float64\n&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">int64</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is a int\n&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is a nil\n&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is a string\n&quot;</span>, i)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Param #%d is unknown\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口实例：使用Sorter接口排序"><a href="#接口实例：使用Sorter接口排序" class="headerlink" title="接口实例：使用Sorter接口排序"></a>接口实例：使用Sorter接口排序</h3><p><code>sort</code> 包要对一组数字或字符串排序，需要实现三个方法：反映元素个数的 <code>Len()</code> 方法、比较第 <code>i</code> 和 <code>j</code> 个元素的 <code>Less(i, j)</code> 方法以及交换第 <code>i</code> 和 <code>j</code> 个元素的 <code>Swap(i, j)</code> 方法</p><p>排序函数的算法只会使用到这三个方法（可以使用任何排序算法来实现，此处我们使用冒泡排序）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Sorter)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> pass := <span class="number">1</span>; pass &lt; data.Len(); pass++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; data.Len() - pass; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> data.Less(i+<span class="number">1</span>, i) &#123;</span><br><span class="line">                data.Swap(i, i + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Sort</code> 函数接收一个接口类型的参数：<code>Sorter</code> ，它声明了这些方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sorter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <code>int</code> 是待排序序列长度的类型，而不是说要排序的对象一定要是一组 <code>int</code>，现在若想对一个 <code>int</code> 数组排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntArray []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntArray)</span></span> Swap(i, j <span class="type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="type">int</span>&#123;<span class="number">74</span>, <span class="number">59</span>, <span class="number">238</span>, <span class="number">-784</span>, <span class="number">9845</span>, <span class="number">959</span>, <span class="number">905</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">7586</span>, <span class="number">-5467984</span>, <span class="number">7586</span>&#125;</span><br><span class="line">a := sort.IntArray(data) <span class="comment">//conversion to type IntArray from package sort</span></span><br><span class="line">sort.Sort(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以给一个空接口类型的变量 <code>var val interface &#123;&#125;</code> 赋任何类型的值</p><p>每个 <code>interface &#123;&#125;</code> 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针</p><h4 id="构建通用类型"><a href="#构建通用类型" class="headerlink" title="构建通用类型"></a>构建通用类型</h4><p>前面的排序实例中可以实现对<code>int</code>、<code>float</code>、<code>string</code>数组的排序，对于其他类型的排序可以使用空接口：<code>Element：type Element interface&#123;&#125;</code></p><p>然后定义一个容器类型结构体<code>Vector</code>，包含一个<code>Element</code>类型元素的切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector <span class="keyword">struct</span> &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Vector</code> 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素可以是不同类型的。我们为它定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素，再定一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span></span> At(i <span class="type">int</span>) Element &#123;</span><br><span class="line"><span class="keyword">return</span> p.a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span></span> Set(i <span class="type">int</span>, e Element) &#123;</span><br><span class="line">p.a[i] = e</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言</p><h5 id="通用类型节点数据结构"><a href="#通用类型节点数据结构" class="headerlink" title="通用类型节点数据结构"></a>通用类型节点数据结构</h5><p>在列表和树等数据结构中定义时使用了节点的递归型结构体类型，现在可以使用空接口作为数据字段的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">le   *Node</span><br><span class="line">data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ri   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(left, right *Node)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Node&#123;left, <span class="literal">nil</span>, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> SetData(data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">n.data = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">root := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">root.SetData(<span class="string">&quot;root node&quot;</span>)</span><br><span class="line"><span class="comment">// make child (leaf) nodes:</span></span><br><span class="line">a := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">a.SetData(<span class="string">&quot;left node&quot;</span>)</span><br><span class="line">b := NewNode(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">b.SetData(<span class="string">&quot;right node&quot;</span>)</span><br><span class="line">root.le = a</span><br><span class="line">root.ri = b</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, root) <span class="comment">// Output: &amp;&#123;0x125275f0 root node 0x125275e0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复制数据切片至空接口切片"><a href="#复制数据切片至空接口切片" class="headerlink" title="复制数据切片至空接口切片"></a>复制数据切片至空接口切片</h4><p>若有一个 <code>myType</code> 类型的数据切片，将切片中的数据复制到一个空接口切片中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = dataSlice</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>此时将会编译出错：</strong><code>cannot use dataSlice (type []myType) as type []interface &#123; &#125; in assignment</code></p><p>因为它们两个在内存中的布局不一样，必须用<code>for-range</code>一个一个显示赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口到接口"><a href="#接口到接口" class="headerlink" title="接口到接口"></a>接口到接口</h4><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 <code>Go</code> 语言动态的一面，可以拿它和 <code>Ruby</code> 和 <code>Python</code> 这些动态语言相比较</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ai AbsInterface</span><br><span class="line"><span class="keyword">type</span> SqrInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sqr() float</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> si SqrInterface</span><br><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = pp</span><br><span class="line">ai = empty.(AbsInterface)</span><br><span class="line">si = ai.(SqrInterface)</span><br><span class="line">empty = si</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myPrintInterface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">(x myInterface)</span></span> &#123;</span><br><span class="line">x.(myPrintInterface).<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>x</code> 转换为 <code>myPrintInterface</code> 类型是完全动态的：只要 <code>x</code> 的底层类型（动态类型）定义了 <code>print</code> 方法这个调用就可以正常运行（译注：若 <code>x</code> 的底层类型未定义 <code>print</code> 方法，此处类型断言会导致 <code>panic</code>，最佳实践应该为 <code>if mpi, ok := x.(myPrintInterface); ok &#123; mpi.print() &#125;</code></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>计算机程序在运行时，可以访问、检测和修改它本身状态或行为的能力</p><p>在reflect包中定义了一个接口和一个结构体，即reflect.Type和reflect.Value结构体，它们提供了很多函数获取存储在接口中的类型信息</p><ul><li>reflect.Type接口主要提供关于类型相关的信息</li><li>reflect.Value结构体主要提供关于值相关的信息，可以获取甚至改变类型的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TypeOf用于提取一个接口中值的类型信息，实参会先被转化为空接口类型，这样，实参的类型信息、方法集、值信息都存储到interface{}中了；ValueOf()返回一个结构体变量，包含类型信息及实际值</p><h3 id="反射的三大法则"><a href="#反射的三大法则" class="headerlink" title="反射的三大法则"></a>反射的三大法则</h3><ul><li><p>反射可以将<code>接口类型变量</code>转换为<code>反射类型对象</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">6.8</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>,v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;Kind is float64:&quot;</span>,v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value&quot;</span>,v.Float())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>反射可以将<code>反射类型对象</code>转换为<code>接口类型变量</code></p><p>Go中的反射可以创造自己反面类型的对象，一个<code>reflect.Value</code>类型的变量，可以使用<code>Interface()</code>方法恢复其接口类型的值；该方法会将type和value信息打包并填充到一个接口变量中，然后返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>若要修改<code>反射类型对象</code>，则其值必须是<code>可写的</code></p><p>要让反射对象具备可写性需要注意：创建反射对象时传入变量的是指针；使用Elem()方法返回指针指向的数据</p><ul><li><p>不是接收变量指针创建的反射对象，是不具备可写性的</p></li><li><p>是否具备可写性，可使用CanSet方法得知</p></li><li><p>对不具备可写性的对象修改是无意义的，也是不合法的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Go web&quot;</span></span><br><span class="line"></span><br><span class="line">v1 := reflect.ValueOf(&amp;name)</span><br><span class="line">v2 := v1.Elem()</span><br><span class="line"></span><br><span class="line"><span class="comment">//v1不具有可写性，v2具有可写性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="修改反射对象"><a href="#修改反射对象" class="headerlink" title="修改反射对象"></a>修改反射对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetBool(x <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetBytes(x []<span class="type">byte</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetFloat(x <span class="type">float64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetInt(x <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> SetString(x <span class="type">string</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反射包"><a href="#反射包" class="headerlink" title="反射包"></a>反射包</h3><h4 id="方法和类型的反射"><a href="#方法和类型的反射" class="headerlink" title="方法和类型的反射"></a>方法和类型的反射</h4><p>反射包的 <code>Type</code> 表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口</p><p><code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>返回被检查对象的类型和值</p><p>实际上，反射是通过检查一个接口的值，变量首先被转换一个空接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反射可以从接口值反射到对象，也可以从对象反射回接口值</p><p> <code>Type</code> 和 <code>Value</code> 都有 <code>Kind()</code> 方法返回一个常量来表示类型， <code>Kind()</code> 总是返回底层类型，同样 <code>Value</code> 有叫做 <code>Int()</code> 和 <code>Float()</code> 的方法可以获取存储在内部的值</p><p>变量 <code>v</code> 的 <code>Interface()</code> 可以得到还原（接口）值，可以这样打印 <code>v</code> 的值：<code>fmt.Println(v.Interface())</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blog: Laws of Reflection</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, reflect.TypeOf(x))</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind:&quot;</span>, v.Kind())</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Printf(<span class="string">&quot;value is %5.2e\n&quot;</span>, v.Interface())</span><br><span class="line">y := v.Interface().(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="type">float64</span></span><br><span class="line">value: <span class="number">3.4</span></span><br><span class="line"><span class="keyword">type</span>: <span class="type">float64</span></span><br><span class="line">kind: <span class="type">float64</span></span><br><span class="line">value: <span class="number">3.4</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line">value is <span class="number">3.40e+00</span></span><br><span class="line"><span class="number">3.4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过反射设置值"><a href="#通过反射设置值" class="headerlink" title="通过反射设置值"></a>通过反射设置值</h4><p>可以使用 <code>CanSet()</code> 方法测试是否可设置反射值，并不是所有的都有该属性</p><p>若要将上述<code>v</code>的值设置为<code>3.1415</code>可以小心使用<code>v.SetFloat(3.1415)</code>，但该方法不一定能够成功</p><p>可以使用 <code>Elem()</code> 函数，这间接地使用指针：<code>v = v.Elem()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// setting a value:</span></span><br><span class="line"><span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;type of v:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">v = v.Elem()</span><br><span class="line">fmt.Println(<span class="string">&quot;The Elem of v is: &quot;</span>, v)</span><br><span class="line">fmt.Println(<span class="string">&quot;settability of v:&quot;</span>, v.CanSet())</span><br><span class="line">v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> of v: *<span class="type">float64</span></span><br><span class="line">settability of v: <span class="literal">false</span></span><br><span class="line">The Elem of v is:  &lt;<span class="type">float64</span> Value&gt;</span><br><span class="line">settability of v: <span class="literal">true</span></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">&lt;<span class="type">float64</span> Value&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反射中有些内容是需要用地址去改变它的状态的</p><h4 id="反射结构"><a href="#反射结构" class="headerlink" title="反射结构"></a>反射结构</h4><p>有时需要反射一个结构类型。<code>NumField()</code> 方法返回结构内的字段数量；通过一个 <code>for</code> 循环用索引取得每个字段的值 <code>Field(i)</code></p><p>可以调用签名在结构上的方法，使用索引 <code>n</code> 来调用：<code>Method(n).Call(nil)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotknownType <span class="keyword">struct</span> &#123;</span><br><span class="line">s1, s2, s3 <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NotknownType)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.s1 + <span class="string">&quot; - &quot;</span> + n.s2 + <span class="string">&quot; - &quot;</span> + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable to investigate:</span></span><br><span class="line"><span class="keyword">var</span> secret <span class="keyword">interface</span>&#123;&#125; = NotknownType&#123;<span class="string">&quot;Ada&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Oberon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">value := reflect.ValueOf(secret) <span class="comment">// &lt;main.NotknownType Value&gt;</span></span><br><span class="line">typ := reflect.TypeOf(secret)    <span class="comment">// main.NotknownType</span></span><br><span class="line"><span class="comment">// alternative:</span></span><br><span class="line"><span class="comment">// typ := value.Type()  // main.NotknownType</span></span><br><span class="line">fmt.Println(typ)</span><br><span class="line">knd := value.Kind() <span class="comment">// struct</span></span><br><span class="line">fmt.Println(knd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through the fields of the struct:</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Field %d: %v\n&quot;</span>, i, value.Field(i))</span><br><span class="line"><span class="comment">// error: panic: reflect.Value.SetString using value obtained using unexported field</span></span><br><span class="line"><span class="comment">// value.Field(i).SetString(&quot;C#&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the first method, which is String():</span></span><br><span class="line">results := value.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">fmt.Println(results) <span class="comment">// [Ada - Go - Oberon]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.NotknownType</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">Field <span class="number">0</span>: Ada</span><br><span class="line">Field <span class="number">1</span>: Go</span><br><span class="line">Field <span class="number">2</span>: Oberon</span><br><span class="line">[Ada - Go - Oberon]</span><br></pre></td></tr></table></figure><p>但是如果尝试更改一个值，会得到一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.SetString using value obtained using unexported field</span><br></pre></td></tr></table></figure><p>这是因为结构中只有被导出字段（首字母大写）才是可设置的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">int</span></span><br><span class="line">B <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">&quot;skidoo&quot;</span>&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">f := s.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d: %s %s = %v\n&quot;</span>, i,</span><br><span class="line">typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br><span class="line">s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">s.Field(<span class="number">1</span>).SetString(<span class="string">&quot;Sunset Strip&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;t is now&quot;</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: A <span class="type">int</span> = <span class="number">23</span></span><br><span class="line"><span class="number">1</span>: B <span class="type">string</span> = skidoo</span><br><span class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Printf-和反射"><a href="#Printf-和反射" class="headerlink" title="Printf()和反射"></a>Printf()和反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, args ... <span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Printf()</code> 中的 <code>...</code> 参数为空接口类型，它使用反射包来解析这个参数列表，故能够知道它每个参数的类型</p><h3 id="解码任意数据"><a href="#解码任意数据" class="headerlink" title="解码任意数据"></a>解码任意数据</h3><p>json 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := []<span class="type">byte</span>(<span class="string">`&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;`</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure><p><code>f</code>指向的值是一个<code>map</code>，key为字符串，value是自身存储作为空接口类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line"><span class="string">&quot;Age&quot;</span>:  <span class="number">6</span>,</span><br><span class="line"><span class="string">&quot;Parents&quot;</span>: []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="string">&quot;Gomez&quot;</span>,</span><br><span class="line"><span class="string">&quot;Morticia&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要访问该数据可以使用类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := f.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Println(k, <span class="string">&quot;is string&quot;</span>, vv)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Println(k, <span class="string">&quot;is int&quot;</span>, vv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">fmt.Println(k, <span class="string">&quot;is an array:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">fmt.Println(i, u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(k, <span class="string">&quot;is of a type I don’t know how to handle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这种方式可以处理未知的 JSON 数据，同时确保类型安全</p><h3 id="编码和解码流"><a href="#编码和解码流" class="headerlink" title="编码和解码流"></a>编码和解码流</h3><p><code>json</code> 包提供 <code>Decoder</code> 和 <code>Encoder</code> 类型来支持常用 JSON 数据流读写。<code>NewDecoder()</code> 和 <code>NewEncoder()</code> 分别封装了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span></span> *Encoder</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 <code>json.NewEncoder</code> 初始化文件（或者任何实现 <code>io.Writer</code> 的类型），并调用 <code>Encode()</code>；反过来与其对应的是使用 <code>json.NewDecoder</code> 和 <code>Decode()</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span></span> *Decoder</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dec *Decoder)</span></span> Decode(v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目标或源数据要能够被编码就必须实现 <code>io.Writer</code> 或 <code>io.Reader</code> 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 <code>Encoder</code> 和 <code>Decoder</code> 应用场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件</p><h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>的类型都是 <code>*os.File</code>；文件使用指向 <code>os.File</code> 类型的指针表示，也即文件句柄</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile, _ := os.Open(<span class="string">&quot;input.dat&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, readerError := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;The input was: %s&quot;</span>, inputString)</span><br><span class="line">        <span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若文件不存在或无权打开文件，则Open函数会返回一个错误：inputFile, inputError = os.Open</span></span><br><span class="line"><span class="comment">//若文件打开正常，则使用defer inputFile.Close()确保程序退出前关闭该文件；然后使用bufio.NewReader()获得一个读取器变量，通过其可以方便地操作相对高层的string对象，避免操作较底层的字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> Unix 和 Linux 的行结束符是 <code>\n</code>，而 Windows 的行结束符是 <code>\r\n</code>；在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候不用关心操作系统类型，直接使用 <code>\n</code> 即可。另外也可以使用 <code>ReadLine()</code> 方法来实现相同的功能</p><p>一旦读取到文件末尾，<code>readerError</code>的值变为常量<code>io.EOF</code></p><h5 id="将文件内容读入字符串"><a href="#将文件内容读入字符串" class="headerlink" title="将文件内容读入字符串"></a>将文件内容读入字符串</h5><p>可以使用 <code>io/ioutil</code> 中的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 <code>nil</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf, _ := ioutil.ReadFile(inputFile)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(buf))</span><br></pre></td></tr></table></figure><h5 id="带缓冲的读取"><a href="#带缓冲的读取" class="headerlink" title="带缓冲的读取"></a>带缓冲的读取</h5><p>有时文件内容不按行划分或为二进制，此时<code>ReadString()</code>无法使用；可以使用<code>bufio.Reader</code>中的<code>Read()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">...</span><br><span class="line">n, err := inputReader.Read(buf)<span class="comment">//n表示读取到的字节数</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">break</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="按列读取文件数据"><a href="#按列读取文件数据" class="headerlink" title="按列读取文件数据"></a>按列读取文件数据</h5><p>若数据按列排列且用空格分隔，可使用<code>fmt</code>中以<code>FScan...</code>开头的系列函数读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;products2.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> col1, col2, col3 []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> v1, v2, v3 <span class="type">string</span></span><br><span class="line">        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        <span class="comment">// scans until newline</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        col1 = <span class="built_in">append</span>(col1, v1)</span><br><span class="line">        col2 = <span class="built_in">append</span>(col2, v2)</span><br><span class="line">        col3 = <span class="built_in">append</span>(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ABC FUNC GO]</span><br><span class="line">[40 56 45]</span><br><span class="line">[150 280 356]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// var outputWriter *bufio.Writer</span></span><br><span class="line"><span class="comment">// var outputFile *os.File</span></span><br><span class="line"><span class="comment">// var outputError os.Error</span></span><br><span class="line"><span class="comment">// var outputString string</span></span><br><span class="line">outputFile, _ := os.OpenFile(<span class="string">&quot;output.dat&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">outputString := <span class="string">&quot;hello world!\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">outputWriter.WriteString(outputString)</span><br><span class="line">&#125;</span><br><span class="line">outputWriter.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 <code>|</code> 连接），使用的文件权限</p><ul><li><code>os.O_RDONLY</code>：只读  </li><li><code>os.O_WRONLY</code>：只写  </li><li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件 </li><li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为 0</li></ul><p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile()</code> 时传入的第三个参数可以用 0 。而在写文件时，不管是 Unix 还是 Windows，都需要使用 &#96;</p><p>然后创建一个写入器（缓冲区）对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着用 <code>for</code> 循环写入缓冲区：<code>outputWriter.WriteString(outputString)</code></p><p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code></p><p>若写入的东西很简单，可以使用 <code>fmt.Fprintf(outputFile, &quot;Some test data.\n&quot;)</code> 直接将内容写入文件。<code>fmt</code> 包里的 <code>F...</code> 开头的 <code>Print()</code> 函数可以直接写入任何 <code>io.Writer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用fmt.FPrintf()函数写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">os.Stdout.WriteString(<span class="string">&quot;hello, world\n&quot;</span>)<span class="comment">//可以输出到屏幕</span></span><br><span class="line">f, _ := os.OpenFile(<span class="string">&quot;test&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">f.WriteString(<span class="string">&quot;hello, world in a file\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不使用缓冲区，直接将内容写入文件：f.WriteString()</span></span><br></pre></td></tr></table></figure><h3 id="XML数据格式"><a href="#XML数据格式" class="headerlink" title="XML数据格式"></a>XML数据格式</h3><p>如同 <code>json</code> 包一样，也有 <code>xml.Marshal()</code> 和 <code>xml.Unmarshal()</code> 从 XML 中编码和解码数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xml.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t, token xml.Token</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="string">&quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;/FirstName&gt;&lt;LastName&gt;Lynn&lt;/LastName&gt;&lt;/Person&gt;&quot;</span></span><br><span class="line">inputReader := strings.NewReader(input)</span><br><span class="line">p := xml.NewDecoder(inputReader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t, err = p.Token(); err == <span class="literal">nil</span>; t, err = p.Token() &#123;</span><br><span class="line"><span class="keyword">switch</span> token := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> xml.StartElement:</span><br><span class="line">name := token.Name.Local</span><br><span class="line">fmt.Printf(<span class="string">&quot;Token name: %s\n&quot;</span>, name)</span><br><span class="line"><span class="keyword">for</span> _, attr := <span class="keyword">range</span> token.Attr &#123;</span><br><span class="line">attrName := attr.Name.Local</span><br><span class="line">attrValue := attr.Value</span><br><span class="line">fmt.Printf(<span class="string">&quot;An attribute is: %s %s\n&quot;</span>, attrName, attrValue)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> xml.EndElement:</span><br><span class="line">fmt.Println(<span class="string">&quot;End of token&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> xml.CharData:</span><br><span class="line">content := <span class="type">string</span>([]<span class="type">byte</span>(token))</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is the content: %v\n&quot;</span>, content)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Token name: Person</span><br><span class="line">Token name: FirstName</span><br><span class="line">This is the content: Laura</span><br><span class="line">End of token</span><br><span class="line">Token name: LastName</span><br><span class="line">This is the content: Lynn</span><br><span class="line">End of token</span><br><span class="line">End of token</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 <code>[]byte</code>，通过字符串转换让其变得可读性更强</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p><code>recover()</code>内建函数用于从panic或错误场景中恢复：停止终止过程进而恢复正常执行</p><p><code>recover</code> 只能在 <code>defer</code> 修饰的函数中使用：取得 <code>panic()</code> 调用中传递过来的错误值，如果是正常执行，调用 <code>recover()</code> 会返回 <code>nil</code>，且没有其它效果</p><p>即<code>panic()</code> 会导致栈被展开直到 <code>defer</code> 修饰的 <code>recover()</code> 被调用或程序中止</p><p><code>defer</code>-<code>panic()</code>-<code>recover()</code> 某种意义上也是一种像 <code>if</code>，<code>for</code> 的控制流机制</p><h3 id="闭包处理错误"><a href="#闭包处理错误" class="headerlink" title="闭包处理错误"></a>闭包处理错误</h3><p>每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码。结合 defer&#x2F;panic&#x2F;recover 机制和闭包可以得到一个我们马上要讨论的更加优雅的模式。不过这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设所有的函数都有这样的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a type1, b type2)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数的数量和类型是不相关的。给这个类型一个名字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fType1 = <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a type1, b type2)</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在该模式中使用了两个帮助函数：</p><p>1）<code>check()</code>：这是用来检查是否有错误和 panic 发生的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(err <span class="type">error</span>)</span></span> &#123; <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="built_in">panic</span>(err) &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）<code>errorhandler()</code>：这是一个包装函数。接收一个 <code>fType1</code> 类型的函数 <code>fn</code> 并返回一个调用 <code>fn</code> 的函数。里面就包含有 defer&#x2F;recover 机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(fn fType1)</span></span> fType1 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok := <span class="built_in">recover</span>().(<span class="type">error</span>); ok &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;run time panic: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fn(a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当错误发生时会 recover 并打印在日志中；<code>check()</code> 函数会在所有的被调函数中调用，像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">f, _, err := <span class="comment">// call function/method</span></span><br><span class="line">check(err)</span><br><span class="line">t, err := <span class="comment">// call function/method</span></span><br><span class="line">check(err)</span><br><span class="line">_, err2 := <span class="comment">// call function/method</span></span><br><span class="line">check(err2)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 <code>check(err)</code> 即可。在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值</p><h2 id="协程与通道"><a href="#协程与通道" class="headerlink" title="协程与通道"></a>协程与通道</h2><h3 id="带缓冲通道实现一个信号量"><a href="#带缓冲通道实现一个信号量" class="headerlink" title="带缓冲通道实现一个信号量"></a>带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁常见的同步机制，限制对资源的访问，解决读写问题；使用带缓冲的通道可以实现：</p><ul><li>带缓冲通道的容量和同步资源容量相同</li><li>通道长度（当前存放元素个数）与当前资源被使用数量相同</li><li>容量减去通道长度即未处理资源个数（标准信号量的整数值）</li></ul><p>创建一个长度可变但容量为0（字节）的通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> semaphore <span class="keyword">chan</span> Empty</span><br></pre></td></tr></table></figure><p>将可用资源数量<code>N</code>初始化信号量<code>semaphore</code>：<code>sem = make(semaphore,N)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> P(n <span class="type">int</span>) &#123;</span><br><span class="line">e := <span class="built_in">new</span>(Empty)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">s &lt;- e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> V(n <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">&lt;- s</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现互斥的例子</span></span><br><span class="line"><span class="comment">/* mutexes */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Lock() &#123;</span><br><span class="line">s.P(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Unlock()&#123;</span><br><span class="line">s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal-wait */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Wait(n <span class="type">int</span>) &#123;</span><br><span class="line">s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span></span> Signal() &#123;</span><br><span class="line">s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="任务和worker"><a href="#任务和worker" class="headerlink" title="任务和worker"></a>任务和worker</h3><p>假设需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体：</p><h4 id="旧模式：使用共享内存进行同步"><a href="#旧模式：使用共享内存进行同步" class="headerlink" title="旧模式：使用共享内存进行同步"></a>旧模式：使用共享内存进行同步</h4><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，需要对任务池进行加锁保护</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    Musync.Mutex</span><br><span class="line">    Tasks[]*Task</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(pool *Pool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        pool.Mu.Lock()</span><br><span class="line">        <span class="comment">// begin critical section:</span></span><br><span class="line">        task := pool.Tasks[<span class="number">0</span>]        <span class="comment">// take the first task</span></span><br><span class="line">        pool.Tasks = pool.Tasks[<span class="number">1</span>:]  <span class="comment">// update the pool of tasks</span></span><br><span class="line">        <span class="comment">// end critical section</span></span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加锁保证了同一时间只有一个 go 协程可以进入到 <code>pool</code> 中：一项任务有且只有一个worker；但若任务量较多时，频繁地加锁&#x2F;解锁会导致效率降低</p><h4 id="新模式：使用通道"><a href="#新模式：使用通道" class="headerlink" title="新模式：使用通道"></a>新模式：使用通道</h4><p>使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 <code>N</code> 应该根据任务数量进行调整；主线程扮演着 Master 节点角色，可能写成如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pending, done := <span class="built_in">make</span>(<span class="keyword">chan</span> *Task), <span class="built_in">make</span>(<span class="keyword">chan</span> *Task)</span><br><span class="line">    <span class="keyword">go</span> sendWork(pending)       <span class="comment">// put tasks with work on the channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;   <span class="comment">// start N goroutines to do work</span></span><br><span class="line">    <span class="keyword">go</span> Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">consumeWork(done)          <span class="comment">// continue with the processed tasks</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in,out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="网络及网页应用"><a href="#网络及网页应用" class="headerlink" title="网络及网页应用"></a>网络及网页应用</h2><h3 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Starting the server ...&quot;</span>)</span><br><span class="line"><span class="comment">// 创建 listener</span></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:50000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error listening&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听并接受来自客户端的连接</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error accepting&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> doServerStuff(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doServerStuff</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>)</span><br><span class="line"><span class="built_in">len</span>, err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error reading&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received data: %v&quot;</span>, <span class="type">string</span>(buf[:<span class="built_in">len</span>]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个无限 <code>for</code> 循环的 <code>listener.Accept()</code> 来等待客户端的请求。客户端的请求将产生一个 <code>net.Conn</code> 类型的连接变量。然后一个独立的协程使用这个连接执行 <code>doServerStuff()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//打开连接:</span></span><br><span class="line">conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:50000&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//由于目标计算机积极拒绝而无法创建连接</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Error dialing&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">fmt.Println(<span class="string">&quot;First, what is your name?&quot;</span>)</span><br><span class="line">clientName, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;CLIENTNAME %s&quot;, clientName)</span></span><br><span class="line">trimmedClient := strings.Trim(clientName, <span class="string">&quot;\r\n&quot;</span>) <span class="comment">// Windows 平台下用 &quot;\r\n&quot;，Linux平台下使用 &quot;\n&quot;</span></span><br><span class="line"><span class="comment">// 给服务器发送信息直到程序退出：</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;What to send to the server? Type Q to quit.&quot;</span>)</span><br><span class="line">input, _ := inputReader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">trimmedInput := strings.Trim(input, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;input:--%s--&quot;, input)</span></span><br><span class="line"><span class="comment">// fmt.Printf(&quot;trimmedInput:--%s--&quot;, trimmedInput)</span></span><br><span class="line"><span class="keyword">if</span> trimmedInput == <span class="string">&quot;Q&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(trimmedClient + <span class="string">&quot; says: &quot;</span> + trimmedInput))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过 <code>net.Dial()</code> 创建了一个和服务器之间的连接，一旦连接到远程系统，函数就会返回一个<code>Conn</code>类型的接口，此时可以用它发送和接收数据</p><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>http描述了网页服务器如何与客户端浏览器进行通信</p><p>若<code>req</code>是来自html表单的POST请求，<code>&quot;var1&quot;是表单中一个输入域的名称</code>，则可以通过<code>req.FormValue(&quot;var1&quot;)</code>获取；或者先执行<code>request.ParseForm()</code>，然后再获取<code>request.Form[&quot;var1&quot;]</code>的第一个返回参数</p><p><code>var1,found := request.Form[&quot;var1&quot;]</code></p><p>若 <code>var1</code> 并未出现在表单中，<code>found</code> 就是 <code>false</code></p><p>表单属性实际上是 <code>map[string][]string</code> 类型。网页服务器发送一个 <code>http.Response</code> 响应，它是通过 <code>http.ResponseWriter</code> 对象输出的，后者组装了 HTTP 服务器响应，通过对其写入内容，就将数据发送给了 HTTP 客户端</p><p>如何处理请求即是<code>http.HandleFunc()</code>函数完成的</p><h4 id="确保网页健壮性"><a href="#确保网页健壮性" class="headerlink" title="确保网页健壮性"></a>确保网页健壮性</h4><p>当网页的处理函数发生 panic，服务器会简单地终止运行，这会造成严重的影响；我们需要网页能够承受突发问题</p><p>首先想到的是在每个处理函数中使用<code>defer/recover()</code>，但是这样会产生较多重复代码，使用闭包的错误处理模式是更优雅的方案</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logPanics</span><span class="params">(function HandleFunc)</span></span> HandleFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;[%v] caught panic: %v&quot;</span>, request.RemoteAddr, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">function(writer, request)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后用<code>logPanics()</code>包装对处理函数的调用，处理函数现在可以恢复panic调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/test1&quot;</span>,logPanics(SimpleServer))</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/test2&quot;</span>,logPanics(FormServer))</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = <span class="string">`&lt;html&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot; name=&quot;bar&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;text&quot; name=&quot;in&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;&lt;/html&gt;&lt;/body&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandleFnc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a simple get request */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(w, <span class="string">&quot;&lt;h1&gt;hello, world&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a form, both the GET which displays the form</span></span><br><span class="line"><span class="comment">   and the POST which processes it.*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> request.Method &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>:</span><br><span class="line"><span class="comment">/* display the form to the user */</span></span><br><span class="line">io.WriteString(w, form)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;POST&quot;</span>:</span><br><span class="line"><span class="comment">/* handle the form data, note that ParseForm must</span></span><br><span class="line"><span class="comment">   be called before we can extract form data*/</span></span><br><span class="line"><span class="comment">//request.ParseForm();</span></span><br><span class="line"><span class="comment">//io.WriteString(w, request.Form[&quot;in&quot;][0])</span></span><br><span class="line">io.WriteString(w, request.FormValue(<span class="string">&quot;in&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/test1&quot;</span>, logPanics(SimpleServer))</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/test2&quot;</span>, logPanics(FormServer))</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8088&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logPanics</span><span class="params">(function HandleFnc)</span></span> HandleFnc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;[%v] caught panic: %v&quot;</span>, request.RemoteAddr, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">function(writer, request)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go常见陷阱</title>
      <link href="/go%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/"/>
      <url>/go%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><h3 id="数组是值传递"><a href="#数组是值传递" class="headerlink" title="数组是值传递"></a>数组是值传递</h3><p>在函数调用参数中，数组是值传递，无法通过修改数组类型的参数返回结果，必要时需要使用切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数传递切片"><a href="#函数参数传递切片" class="headerlink" title="函数参数传递切片"></a>函数参数传递切片</h3><p>切片实际是一个指向潜在数组的指针，以切片为参数时只需如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBiggest</span><span class="params">( listOfNumbers []<span class="type">int</span> )</span></span> <span class="type">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="切片会导致整个底层数组被锁定"><a href="#切片会导致整个底层数组被锁定" class="headerlink" title="切片会导致整个底层数组被锁定"></a>切片会导致整个底层数组被锁定</h3><p>切片会导致整个底层数组被锁定，底层数组无法释放内存。如果底层数组较大会对内存产生很大的压力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">name := <span class="string">&quot;/path/to/file&quot;</span></span><br><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">headerMap[name] = data[:<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决的方法是将结果克隆一份，这样可以释放底层的数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">headerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">name := <span class="string">&quot;/path/to/file&quot;</span></span><br><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">headerMap[name] = <span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, data[:<span class="number">1</span>]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="map遍历是顺序不固定"><a href="#map遍历是顺序不固定" class="headerlink" title="map遍历是顺序不固定"></a>map遍历是顺序不固定</h3><p>map是一种hash表实现，每次遍历的顺序都可能不一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="built_in">println</span>(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="空指针和空接口不等价"><a href="#空指针和空接口不等价" class="headerlink" title="空指针和空接口不等价"></a>空指针和空接口不等价</h3><p>比如返回了一个错误指针，但是并不是空的error接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnsError</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *MyError = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> bad() &#123;</span><br><span class="line">p = ErrBad</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p <span class="comment">// Will always return a non-nil error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="不同Goroutine之间不满足顺序一致性内存模型"><a href="#不同Goroutine之间不满足顺序一致性内存模型" class="headerlink" title="不同Goroutine之间不满足顺序一致性内存模型"></a>不同Goroutine之间不满足顺序一致性内存模型</h3><p>因为在不同的Goroutine，main函数中无法保证能打印出<code>hello, world</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决的办法是用显式同步：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line">&lt;-done</span><br><span class="line"><span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>msg的写入是在channel发送之前，所以能保证打印<code>hello, world</code></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="循环中defer"><a href="#循环中defer" class="headerlink" title="循环中defer"></a>循环中defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是错误的方式，当循环结束时文件没有关闭</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环内结尾处的 <code>defer</code> 没有执行，所以文件一直没有关闭，不应该使用<code>defer</code></p><p><strong><code>defer</code> 仅在函数返回时才会执行，在循环内的结尾或其他一些有限范围的代码内不会执行</strong></p><h3 id="recover必须在defer函数中运行"><a href="#recover必须在defer函数中运行" class="headerlink" title="recover必须在defer函数中运行"></a>recover必须在defer函数中运行</h3><p><code>recover</code>捕获的是祖父级调用时的异常，直接调用时无效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()</span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接<code>defer</code>调用也是无效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>()</span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defer</code>调用时多层嵌套依然无效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">recover</span>() &#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须在<code>defer</code>函数中直接调用才有效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main函数提前退出"><a href="#main函数提前退出" class="headerlink" title="main函数提前退出"></a>main函数提前退出</h3><p>后台Goroutine无法保证完成任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通过Sleep来回避并发中的问题"><a href="#通过Sleep来回避并发中的问题" class="headerlink" title="通过Sleep来回避并发中的问题"></a>通过Sleep来回避并发中的问题</h3><p>休眠并不能保证输出完整的字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似的还有通过插入调度语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="built_in">println</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包错误引用同一个变量"><a href="#闭包错误引用同一个变量" class="headerlink" title="闭包错误引用同一个变量"></a>闭包错误引用同一个变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改进的方法是在每轮迭代中生成一个局部变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">i := i</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者是通过函数参数传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go包</title>
      <link href="/go%E5%8C%85/"/>
      <url>/go%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><h4 id="tar-实现tar格式压缩文件的存取"><a href="#tar-实现tar格式压缩文件的存取" class="headerlink" title="tar(实现tar格式压缩文件的存取)"></a>tar(实现tar格式压缩文件的存取)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">type Format</span></span><br><span class="line"><span class="comment">func (f Format) String() string</span></span><br><span class="line"><span class="comment">type Header</span></span><br><span class="line"><span class="comment">func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)</span></span><br><span class="line"><span class="comment">func (h *Header) FileInfo() fs.FileInfo</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">func NewReader(r io.Reader) *Reader</span></span><br><span class="line"><span class="comment">func (tr *Reader) Next() (*Header,error)</span></span><br><span class="line"><span class="comment">func (tr *Reader) Read(b []byte) (int,error)</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">func (tw *Writer) Close() error</span></span><br><span class="line"><span class="comment">func (tw *Writer) Flush() error</span></span><br><span class="line"><span class="comment">func (tw *Writer) Write(b []byte) (int,error)</span></span><br><span class="line"><span class="comment">func (tw *Writer) WriteHeader(hdr *Header) error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="Header：表示tar文件里单个头"><a href="#Header：表示tar文件里单个头" class="headerlink" title="Header：表示tar文件里单个头"></a>Header：表示tar文件里单个头</h5><p>*<em>FileInfoHeader(fi fs.FileInfo,link string) (<em>Header,error)</em></em></p><p>返回一个根据fi填写了部分字段的Header，若fi描述了一个符号链接，则函数将link参数作为链接目标，若fi描述一个目录，则在名字后加斜杠</p><h5 id="Reader：提供对tar档案文件的顺序读取"><a href="#Reader：提供对tar档案文件的顺序读取" class="headerlink" title="Reader：提供对tar档案文件的顺序读取"></a>Reader：提供对tar档案文件的顺序读取</h5><p>*<em>NewReader(r io.Reader) <em>Reader</em></em></p><p>创建一个从r读取的Reader</p><p>**(tr <em>Reader) Next() (*Header,error)</em>*</p><p>转入tar档案文件下一记录，返回下一记录的头域</p><p>**(tr <em>Reader) Read(b []byte) (n int,err error)</em>*</p><p>从档案文件当前记录读取数据到记录末端返回(0,EOF)，直到调用Next转下一记录</p><h5 id="Writer：提供POSIX-1格式的tar档案文件顺序写入"><a href="#Writer：提供POSIX-1格式的tar档案文件顺序写入" class="headerlink" title="Writer：提供POSIX.1格式的tar档案文件顺序写入"></a>Writer：提供POSIX.1格式的tar档案文件顺序写入</h5><p>*<em>NewWriter(w io.Writer) <em>Writer</em></em></p><p>创建一个写入w的*Writer</p><p>**(tw <em>Writer) WriterHeader(hdr <em>Header) error</em></em></p><p>写入hdr并准备接受文件内容，Header.Size取决于下一个文件能写入多少字节，若非首次调用本方法会调用Flush，在close后调用会返回ErrWriterAfterClose</p><p>**(tw <em>Writer) Write(b []byte) (n int,err error)</em>*</p><p>Write向tar档案文件的当前记录中写入数据，若写入数据总数超出上一次调用WriteHeader的参数hdr.Size字节，返回ErrWriteTooLong错误</p><p>**(tw <em>Writer) Flush() error</em>*</p><p>结束当前文件的写入</p><p>**(tw <em>Writer) Close() error</em>*</p><p>关闭tar档案文件，将缓冲中未写入下层的io.Writer接口的数据刷新到下层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//FileInfoHeader</span></span><br><span class="line">    <span class="comment">//func FileInfoHeader(fi fs.FileInfo,link string) (*Header,error)</span></span><br><span class="line">    fileinfo,err := os.Stat(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    h,err := tar.FileInfoHeader(fileinfo,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    h.Linkname = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    h.Gname = <span class="string">&quot;test&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(h.AccessTime,h.ChangeTime, h.Devmajor, h.Devminor, h.Gid,  h.Gname, h.Linkname, h.ModTime, h.Mode, h.Name, h.Size,h.Typeflag, h.Uid, h.Uname, h.Xattrs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FileInfo返回Header对应的文件信息</span></span><br><span class="line">    <span class="comment">//func (h *Header) FileInfo() fs.FileInfo</span></span><br><span class="line">    f,err := os.Open(<span class="string">&quot;sdk/test.tar&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    r := tar.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> hdr,err := r.Next(); err != io.EOF; hdr,err = r.Next() &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileInfo := hdr.FileInfo()</span><br><span class="line">fmt.Println(fileInfo.Name())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转入tar档案文件下一记录，返回下一记录的头域</span></span><br><span class="line">    <span class="comment">//func (tr *Reader) Next() (*Header,error)</span></span><br><span class="line">    <span class="comment">//func (tr *Reader) Read(b []byte) (int,error)</span></span><br><span class="line">    r := tar.NewReader(strings.NewReader(<span class="string">&quot;test.tar&quot;</span>))</span><br><span class="line">    h,err := r.Next()</span><br><span class="line">    fmt.Println(h,err)</span><br><span class="line">    </span><br><span class="line">    n,err := tar.NewReader(strings.NewReader(<span class="string">&quot;test.log&quot;</span>)).Read(<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>))</span><br><span class="line">    fmt.Println(n,err)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Close关闭tar档案文件，会将缓冲中未写入下层的io.Writer接口的数据刷新到下层</span></span><br><span class="line">    <span class="comment">//func (tw *Writer) Close() error</span></span><br><span class="line">    f,err := os.Create(<span class="string">&quot;sdk/demo.tar&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    tw := tar.NewWriter(f)</span><br><span class="line">    <span class="keyword">defer</span> tw.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func RegisterCompressor(method uint16,comp Compressor)</span></span><br><span class="line"><span class="comment">func RegisterDecompressor(method unit16,dcomp Decompressor)</span></span><br><span class="line"><span class="comment">type Compressor </span></span><br><span class="line"><span class="comment">type Decompressor</span></span><br><span class="line"><span class="comment">type File</span></span><br><span class="line"><span class="comment">func (f *File) DataOffset() (offset int64,err error)</span></span><br><span class="line"><span class="comment">func (f *File) Open() (io.ReadCloser,error)</span></span><br><span class="line"><span class="comment">type FileHeader</span></span><br><span class="line"><span class="comment">func FileInfoHeader(fi fs.FileInfo) (*FileHeader,error)</span></span><br><span class="line"><span class="comment">func (h *FileHeader) FileInfo() fs.FileInfo</span></span><br><span class="line"><span class="comment">func (h *FileHeader) ModTime() time.Time</span></span><br><span class="line"><span class="comment">func (h *FileHeader) Mode() (mode fs.FileMode)</span></span><br><span class="line"><span class="comment">func (h *FileHeader) SetModTime(t time.Time)</span></span><br><span class="line"><span class="comment">func (h *FileHeader) SetMode(mode fs.FileMode)</span></span><br><span class="line"><span class="comment">type ReadCloser</span></span><br><span class="line"><span class="comment">func OpenReader(name string) (*ReadCloser,error)</span></span><br><span class="line"><span class="comment">func (rc *ReadCloser) Close() error</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">func NewReader(r io.ReaderAt,size int64) (*Reader,error)</span></span><br><span class="line"><span class="comment">func (r *Reader) Open(name string) (fs.File,error)</span></span><br><span class="line"><span class="comment">func (z *Reader) RegisterDecompressor(method unit16,dcomp Decompressor)</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">func (w *Writer) Close() error</span></span><br><span class="line"><span class="comment">func (w *Writer) Crteate(name string) (io.Writer,error)</span></span><br><span class="line"><span class="comment">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer,error)</span></span><br><span class="line"><span class="comment">func (w *Writer) Flush() error</span></span><br><span class="line"><span class="comment">func (w *Writer) RegisterCompressor(method unit16,comp Compressor)</span></span><br><span class="line"><span class="comment">func (w *Writer) SetComment(comment string) error</span></span><br><span class="line"><span class="comment">func (w *Writer) SetOffset(n int64)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h5><h6 id="读取文件内容并压缩"><a href="#读取文件内容并压缩" class="headerlink" title="读取文件内容并压缩"></a>读取文件内容并压缩</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedFile</span><span class="params">(file *os.File,prefix <span class="type">string</span>,zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,err := file.Stat()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || info.IsDir() &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    header,err := zip.FileInfoHeader(info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    header.Name = prefix + <span class="string">&quot;/&quot;</span> + header.Name</span><br><span class="line">    writer,err := zw.CreateHeader(header)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _,err = io.Copy(writer,file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f,_ := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="comment">//压缩文件</span></span><br><span class="line">    dst,_ := os.Create(<span class="string">&quot;test.zip&quot;</span>)</span><br><span class="line">    zipWriter := zip.NewWriter(dst)</span><br><span class="line">    <span class="keyword">if</span> err := CompressFile(f,<span class="string">&quot;&quot;</span>,zipWriter); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure to check the error on Close.</span></span><br><span class="line">    <span class="keyword">if</span> err := zipWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompressedFile是将文件内容进行压缩，若想将目录进行压缩则将目录中的文件提取出来然后调用CompressedFile将文件压缩并写入zip.Writer即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Compress 压缩文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compress</span><span class="params">(file *os.File, prefix <span class="type">string</span>, zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,err := file.Stat()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是目录调用CompressedDir</span></span><br><span class="line">    <span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">        <span class="keyword">return</span> CompressedDir(file, prefix, zw)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若是文件调用CompressedFile</span></span><br><span class="line">    <span class="keyword">return</span> CompressedFile(file, prefix, zw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CompressedDir</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedDir</span><span class="params">(file *os.File,prefix <span class="type">string</span>,zw *zip.Writer)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    info,_ := file.Stat()</span><br><span class="line">    prefix = prefix + <span class="string">&quot;/&quot;</span> + info.Name()</span><br><span class="line">    dirInfo,err := file.Readdir(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,f := <span class="keyword">range</span> dirInfo &#123;</span><br><span class="line">        f,err := os.Open(file.Name() + <span class="string">&quot;/&quot;</span> + f.Name())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = Compress(f,prefix,zw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将数据直接写入压缩文件"><a href="#将数据直接写入压缩文件" class="headerlink" title="将数据直接写入压缩文件"></a>将数据直接写入压缩文件</h6><p>将格式化数据写入压缩文件让用户下载，只对数据进行压缩不在本地生成文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressedData</span><span class="params">(data *bytes.Buffer,dest <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    zipBuffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    zipWriter := zip.NewWriter(zipBuffer)</span><br><span class="line">    <span class="comment">// Create entry in zip file</span></span><br><span class="line">    zipEntry,err := zipWriter.Create(dest)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Write content into zip writer</span></span><br><span class="line">    <span class="keyword">if</span> _,err := zipEntry.Write(data.Bytes());err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure to check the error on Close.</span></span><br><span class="line">    <span class="keyword">if</span> err := zipWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h6><p>DeCompressed负责读取压缩文件并调用deCompressed，将读取的内容写入解压缩后的文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeCompressed</span><span class="params">(src <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    s,_ := os.Open(src)</span><br><span class="line">    info,_ := s.Stat()</span><br><span class="line">    ZipReader,err := zip.NewReader(s,info.Size())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,f := <span class="keyword">range</span> ZipReader.File &#123;</span><br><span class="line">        <span class="keyword">if</span> err := deCompressed(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deCompressed</span><span class="params">(f *zip.File)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    d, _ := os.Create(f.Name)</span><br><span class="line">    unzipFile,err := f.Open()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> _,err := io.Copy(d.unzipFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := unzipFile.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bufio（实现有缓冲的I-x2F-O）"><a href="#Bufio（实现有缓冲的I-x2F-O）" class="headerlink" title="Bufio（实现有缓冲的I&#x2F;O）"></a>Bufio（实现有缓冲的I&#x2F;O）</h3><p>主要提供一些操作io缓存流的函数和方法，有时为了提高针对流操作的效率，不然不能缺少针对缓冲流的相关操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func ScanBytes(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">func ScanLines(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">func ScanRunes(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">func ScanWords(data []byte, atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">type ReadWriter</span></span><br><span class="line"><span class="comment">func NewReadWriter(r *Reader,w *Writer) *ReadWriter</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">func NewReader(rd io.Reader) *Reader</span></span><br><span class="line"><span class="comment">func NewReaderSize(rd io.Reader,size int) *Reader</span></span><br><span class="line"><span class="comment">func (b *Reader) Buffered() int</span></span><br><span class="line"><span class="comment">func (b *Reader) Discard(n int) (discarded int,err error)</span></span><br><span class="line"><span class="comment">func (b *Reader) Peek(n int) ([]byte,error)</span></span><br><span class="line"><span class="comment">func (b *Reader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadRune() (r rune, size int, err error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</span></span><br><span class="line"><span class="comment">func (b *Reader) ReadString(delim byte) (string, error)</span></span><br><span class="line"><span class="comment">func (b *Reader) Reset(r io.Reader)</span></span><br><span class="line"><span class="comment">func (b *Reader) Size() int</span></span><br><span class="line"><span class="comment">func (b *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">func (b *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">type Scanner</span></span><br><span class="line"><span class="comment">func NewScanner(r io.Reader) *Scanner</span></span><br><span class="line"><span class="comment">func (s *Scanner) Buffer(buf []byte,max int)</span></span><br><span class="line"><span class="comment">func (s *Scanner) Bytes() []byte</span></span><br><span class="line"><span class="comment">func (s *Scanner) Err() error</span></span><br><span class="line"><span class="comment">func (s *Scanner) Scan() bool</span></span><br><span class="line"><span class="comment">func (s *Scanner) Split(split SplitFunc)</span></span><br><span class="line"><span class="comment">func (s *Scanner) Text() string</span></span><br><span class="line"><span class="comment">type SplitFunc</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">func NewWriter(w io.Writer) *Writer</span></span><br><span class="line"><span class="comment">func NewWriterSize(w io.Writer,size int) *Writer</span></span><br><span class="line"><span class="comment">func (b *Writer) Available() int</span></span><br><span class="line"><span class="comment">func (b *Writer) Buffered() int</span></span><br><span class="line"><span class="comment">func (b *Writer) Flush() error</span></span><br><span class="line"><span class="comment">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">func (b *Writer) Reset(w io.Writer)</span></span><br><span class="line"><span class="comment">func (b *Writer) Size() int</span></span><br><span class="line"><span class="comment">func (b *Writer) Write(p []byte) (nn int, err error)</span></span><br><span class="line"><span class="comment">func (b *Writer) WriteByte(c byte) error</span></span><br><span class="line"><span class="comment">func (b *Writer) WriteRune(r rune) (size int, err error)</span></span><br><span class="line"><span class="comment">func (b *Writer) WriteString(s string) (int, error)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ScanBytes逐字节读取数据</span></span><br><span class="line"><span class="comment">*func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := strings.NewReader(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">bs := bufio.NewScanner(s)</span><br><span class="line">bs.Split(bufio.ScanBytes)</span><br><span class="line"><span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ScanLines逐行读取数据</span></span><br><span class="line"><span class="comment">*func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := strings.NewReader(<span class="string">&quot;Hello 世界\nhaha&quot;</span>)</span><br><span class="line">bs := bufio.NewScanner(s)</span><br><span class="line">bs.Split(bufio.ScanLines)</span><br><span class="line"><span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ScanRunes逐字读取数据</span></span><br><span class="line"><span class="comment">*func ScanRunes(data []byte,atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := strings.NewReader(<span class="string">&quot;hello 世界&quot;</span>)</span><br><span class="line">bs := bufio.NewScanner(s)</span><br><span class="line">bs.Split(bufio.ScanRunes)</span><br><span class="line"><span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    h</span></span><br><span class="line"><span class="comment">    e</span></span><br><span class="line"><span class="comment">    l</span></span><br><span class="line"><span class="comment">    l</span></span><br><span class="line"><span class="comment">    o</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    世</span></span><br><span class="line"><span class="comment">    界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ScanWords逐词读取数据</span></span><br><span class="line"><span class="comment">*func ScanWords(data []byte,atEOF bool) (advance int,token []byte,err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := strings.NewReader(<span class="string">&quot;hello world! 世界 shijie sh&quot;</span>)</span><br><span class="line">bs := bufio.NewScanner(s)</span><br><span class="line">bs.Split(bufio.ScanWords)</span><br><span class="line"><span class="keyword">for</span> bs.Scan() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bs.Text())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出:</span></span><br><span class="line"><span class="comment">    hello</span></span><br><span class="line"><span class="comment">    world!</span></span><br><span class="line"><span class="comment">    世界</span></span><br><span class="line"><span class="comment">    shijie</span></span><br><span class="line"><span class="comment">    sh</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   NewReadWriter封装r和w为一个bufio。ReadWriter对象既可读也可写</span></span><br><span class="line"><span class="comment">   *func NewReadWriter(r *Reader,w *Writer) *ReadWriter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   b := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="type">byte</span>,<span class="number">0</span>))</span><br><span class="line">   bw := bufio.NewWriter(b)</span><br><span class="line">   s := strings.NewReader(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">   br := bufio.NewReader(s)</span><br><span class="line">   rw := bufio.NewReadWriter(br,bw)</span><br><span class="line">   p,_ := rw.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s\n&quot;</span>,<span class="type">string</span>(p))</span><br><span class="line"></span><br><span class="line">   rw.WriteString(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   rw.Flush()</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   NewReader读取数据存放于Reader中</span></span><br><span class="line"><span class="comment">   *func NewReader(rd io.Reader) *Reader</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   b := bufio.NewReader(os.Stdin)</span><br><span class="line">   s,_ := b.ReadString(<span class="string">&#x27;\n&#x27;</span>)<span class="comment">//读取字符直到首次出现回车</span></span><br><span class="line">   fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Buffered方法返回可从缓冲区中读出数据的字节数</span></span><br><span class="line"><span class="comment">*func (b *Reader) Buffered() int</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Peek返回输入流下n个字节且不会移动位置，返回的[]byte只在下一次调用读取操作前合法，若Peek返回的切片长度比n小，它也会返回一个错误说明原因，若n比缓冲尺寸大，返回的错误将是ErrBufferFull</span></span><br><span class="line"><span class="comment">*func (b *Reader) Peek(n int) ([]byte,error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Read从b中读出数据存放到p中，返回读出的字节数和遇到的错误</span></span><br><span class="line"><span class="comment">    若缓存不为空则只能读出缓存中存在的数据，不会从底层io.Reader读取</span></span><br><span class="line"><span class="comment">    若缓存为空，则：</span></span><br><span class="line"><span class="comment">    1、若len(p) &gt;= 缓存大小，直接从底层io.Reader中读出到p中</span></span><br><span class="line"><span class="comment">    2、若len(p) &lt; 缓存大小，将数据从底层读取到缓存中，再从缓存中读取到p中</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Read(p []byte) (n int,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Reset方法丢弃所有的缓存数据，重置所有的状态且将缓存读切换到r</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Reset(r io.Reader)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;ABCDEF&quot;</span>)</span><br><span class="line">   str := strings.NewReader(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">  br := bufio.NewReader(s)</span><br><span class="line">   b,_ := br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">   br.Reset(str)</span><br><span class="line">   b,_ = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    ABCDEF</span></span><br><span class="line"><span class="comment">123456</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Size方法返回缓存区的大小（以字节为单位）</span></span><br><span class="line"><span class="comment">    *func (b *Reader) Size() int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;ABCDEF&quot;</span>)</span><br><span class="line">    b := bufio.NewReader(s)</span><br><span class="line">    n := b.Size()</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    UnreadByte方法作用是撤销最近一次读出的字节，只要有内容读出就可以使用该方法撤销一个字节</span></span><br><span class="line"><span class="comment">    *func (b *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">    UnreadRune方法的作用是返回最近一次调用的unicode码值，若最近一次读取的不是调用的ReadRune，会返回错误</span></span><br><span class="line"><span class="comment">    *func (b *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">    Err方法返回扫描仪遇到的第一个非EOF错误</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Err() error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获取），并让Scanner的扫描位置移动到下一个token，当抵达输入流结尾或遇到错误而停止时返回false,Err方法此时返回nil</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Scan() bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;asffgghjhjhjk&quot;</span>)</span><br><span class="line">scanner := bufio.NewScanner(s)</span><br><span class="line">flag := scanner.Scan()</span><br><span class="line">fmt.Println(flag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    split方法设置该Scanner()的分割函数，本方法必须在Scan之前调用</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Split(split SplitFunc)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">&quot;1234 5678 1234567901234567&quot;</span></span><br><span class="line">scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>, atEOF <span class="type">bool</span>)</span></span> (advance <span class="type">int</span>, token []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">advance, token, err = bufio.ScanWords(data, atEOF)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">_, err = strconv.ParseInt(<span class="type">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">scanner.Split(split)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s \n&quot;</span>, scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    1234</span></span><br><span class="line"><span class="comment">    5678</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Text方法创建并返回最近一次scan调用生成的token</span></span><br><span class="line"><span class="comment">    *func (s *Scanner) Text() string</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := strings.NewReader(<span class="string">&quot;asvgfgghgjh\nsddgffgfg&quot;</span>)</span><br><span class="line">scanner := bufio.NewScanner(s)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    asvgfgghgjh</span></span><br><span class="line"><span class="comment">sddgffgfg</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Builtin（为go提供一些内置的类型和函数）"><a href="#Builtin（为go提供一些内置的类型和函数）" class="headerlink" title="Builtin（为go提供一些内置的类型和函数）"></a>Builtin（为go提供一些内置的类型和函数）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func append(slice []Type,elems ...Type) []Type</span></span><br><span class="line"><span class="comment">func cap(v Type) int</span></span><br><span class="line"><span class="comment">func close(c chan&lt;- Type)</span></span><br><span class="line"><span class="comment">func complex(r,i FloatType) ComplexType</span></span><br><span class="line"><span class="comment">func copy(dst,src []Type) int</span></span><br><span class="line"><span class="comment">func delete(m map[Type]Type1,key Type)</span></span><br><span class="line"><span class="comment">func imag(c ComplexType) FloatType</span></span><br><span class="line"><span class="comment">func len(v Type) int</span></span><br><span class="line"><span class="comment">func make(t Type,size ...IntegerType) Type</span></span><br><span class="line"><span class="comment">func new(Type) *Type</span></span><br><span class="line"><span class="comment">func panic(v interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func print(args ...Type)</span></span><br><span class="line"><span class="comment">func println(args ...Type)</span></span><br><span class="line"><span class="comment">func real(c ComplexType) FloatType</span></span><br><span class="line"><span class="comment">func recover() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">type ComplexType</span></span><br><span class="line"><span class="comment">type FloatType</span></span><br><span class="line"><span class="comment">type IntegerType</span></span><br><span class="line"><span class="comment">    type Type</span></span><br><span class="line"><span class="comment">    type Type1</span></span><br><span class="line"><span class="comment">    type bool</span></span><br><span class="line"><span class="comment">    type byte</span></span><br><span class="line"><span class="comment">    type complex128</span></span><br><span class="line"><span class="comment">    type complex64</span></span><br><span class="line"><span class="comment">    type error</span></span><br><span class="line"><span class="comment">    type float32</span></span><br><span class="line"><span class="comment">    type float64</span></span><br><span class="line"><span class="comment">    type int</span></span><br><span class="line"><span class="comment">    type int16</span></span><br><span class="line"><span class="comment">    type int32</span></span><br><span class="line"><span class="comment">    type int64</span></span><br><span class="line"><span class="comment">    type int8</span></span><br><span class="line"><span class="comment">    type rune</span></span><br><span class="line"><span class="comment">    type string</span></span><br><span class="line"><span class="comment">    type uint</span></span><br><span class="line"><span class="comment">    type uint16</span></span><br><span class="line"><span class="comment">    type uint32</span></span><br><span class="line"><span class="comment">    type uint64</span></span><br><span class="line"><span class="comment">    type uint8</span></span><br><span class="line"><span class="comment">    type uintptr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Bytes（主要提供操作字节切片的函数和方法）"><a href="#Bytes（主要提供操作字节切片的函数和方法）" class="headerlink" title="Bytes（主要提供操作字节切片的函数和方法）"></a>Bytes（主要提供操作字节切片的函数和方法）</h3><p><code>bytes</code> 包和字符串包十分类似，而且还包含一个十分有用的类型 <code>Buffer</code></p><p>长度可变的 <code>bytes</code> 的 buffer，提供 <code>Read()</code> 和 <code>Write()</code> 方法，读写长度未知的 <code>bytes</code> 最好使用 <code>buffer</code></p><h4 id="buffer定义"><a href="#buffer定义" class="headerlink" title="buffer定义"></a>buffer定义</h4><ul><li><code>var buffer bytes.Buffer</code></li><li><code>var r *bytes.Buffer = new(bytes.Buffer)</code></li><li><code>func NewBuffer(buf []byte) *Buffer</code>；<code>NewBuffer</code> 最好用在从 <code>buf</code> 读取的时候</li></ul><h4 id="通过buffer串联字符串"><a href="#通过buffer串联字符串" class="headerlink" title="通过buffer串联字符串"></a>通过buffer串联字符串</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s,ok := getNextString();ok&#123;</span><br><span class="line">        buffer.WriteString(s)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(buffer.String(), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func Compare(a, b []byte) int</span></span><br><span class="line"><span class="comment">    func Contains(b, subslice []byte) bool</span></span><br><span class="line"><span class="comment">    func ContainsAny(b []byte, chars string) bool</span></span><br><span class="line"><span class="comment">    func ContainsRune(b []byte, r rune) bool</span></span><br><span class="line"><span class="comment">    func Count(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func Equal(a, b []byte) bool</span></span><br><span class="line"><span class="comment">    func EqualFold(s, t []byte) bool</span></span><br><span class="line"><span class="comment">    func Fields(s []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func FieldsFunc(s []byte, f func(rune) bool) [][]byte</span></span><br><span class="line"><span class="comment">    func HasPrefix(s, prefix []byte) bool</span></span><br><span class="line"><span class="comment">    func HasSuffix(s, suffix []byte) bool</span></span><br><span class="line"><span class="comment">    func Index(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func IndexAny(s []byte, chars string) int</span></span><br><span class="line"><span class="comment">    func IndexByte(b []byte, c byte) int</span></span><br><span class="line"><span class="comment">    func IndexFunc(s []byte, f func(r rune) bool) int</span></span><br><span class="line"><span class="comment">    func IndexRune(s []byte, r rune) int</span></span><br><span class="line"><span class="comment">    func Join(s [][]byte, sep []byte) []byte</span></span><br><span class="line"><span class="comment">    func LastIndex(s, sep []byte) int</span></span><br><span class="line"><span class="comment">    func LastIndexAny(s []byte, chars string) int</span></span><br><span class="line"><span class="comment">    func LastIndexByte(s []byte, c byte) int</span></span><br><span class="line"><span class="comment">    func LastIndexFunc(s []byte, f func(r rune) bool) int</span></span><br><span class="line"><span class="comment">    func Map(mapping func(r rune) rune, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func Repeat(b []byte, count int) []byte</span></span><br><span class="line"><span class="comment">    func Replace(s, old, new []byte, n int) []byte</span></span><br><span class="line"><span class="comment">    func ReplaceAll(s, old, new []byte) []byte</span></span><br><span class="line"><span class="comment">    func Runes(s []byte) []rune</span></span><br><span class="line"><span class="comment">    func Split(s, sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitAfter(s, sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitAfterN(s, sep []byte, n int) [][]byte</span></span><br><span class="line"><span class="comment">    func SplitN(s, sep []byte, n int) [][]byte</span></span><br><span class="line"><span class="comment">    func Title(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToLower(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToTitle(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToUpper(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</span></span><br><span class="line"><span class="comment">    func ToValidUTF8(s, replacement []byte) []byte</span></span><br><span class="line"><span class="comment">    func Trim(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimLeft(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimPrefix(s, prefix []byte) []byte</span></span><br><span class="line"><span class="comment">    func TrimRight(s []byte, cutset string) []byte</span></span><br><span class="line"><span class="comment">    func TrimRightFunc(s []byte, f func(r rune) bool) []byte</span></span><br><span class="line"><span class="comment">    func TrimSpace(s []byte) []byte</span></span><br><span class="line"><span class="comment">    func TrimSuffix(s, suffix []byte) []byte</span></span><br><span class="line"><span class="comment">type Buffer</span></span><br><span class="line"><span class="comment">    func NewBuffer(buf []byte) *Buffer</span></span><br><span class="line"><span class="comment">    func NewBufferString(s string) *Buffer</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Bytes() []byte</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Cap() int</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Grow(n int)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Len() int</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Next(n int) []byte</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadRune() (r rune, size int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) ReadString(delim byte) (line string, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Reset()</span></span><br><span class="line"><span class="comment">    func (b *Buffer) String() string</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Truncate(n int)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) UnreadByte() error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) UnreadRune() error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteByte(c byte) error</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteRune(r rune) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteString(s string) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">    func NewReader(b []byte) *Reader</span></span><br><span class="line"><span class="comment">    func (r *Reader) Len() int</span></span><br><span class="line"><span class="comment">    func (r *Reader) Read(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadByte() (byte, error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) ReadRune() (ch rune, size int, err error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Reset(b []byte)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Seek(offset int64, whence int) (int64, error)</span></span><br><span class="line"><span class="comment">    func (r *Reader) Size() int64</span></span><br><span class="line"><span class="comment">    func (r *Reader) UnreadByte() error</span></span><br><span class="line"><span class="comment">    func (r *Reader) UnreadRune() error</span></span><br><span class="line"><span class="comment">    func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Compare返回一个整数表示两个[]byte切片按字典比较的结果，若a==b返回0；若a&lt;b返回-1；若a&gt;b返回1。nil参数视为空切片</span></span><br><span class="line"><span class="comment">    *func Compare(a,b []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Contains判断切片b是否包含子切片subslice</span></span><br><span class="line"><span class="comment">    *func Contains(b,subslice []byte) bool&#123;</span></span><br><span class="line"><span class="comment">    return Index(b,subslice) != -1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Count计算s中有多少个不重叠的sep子切片</span></span><br><span class="line"><span class="comment">    *func Count(s,sep []byte) int&#123;</span></span><br><span class="line"><span class="comment">    if len(sep) == 0 &#123;</span></span><br><span class="line"><span class="comment">    return utf8.RuneCount(s) + 1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if len(sep) == 1 &#123;</span></span><br><span class="line"><span class="comment">    return bytealg.Count(s,sep[0])</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    n := 0</span></span><br><span class="line"><span class="comment">    for &#123;</span></span><br><span class="line"><span class="comment">    i := Index(s,sep)</span></span><br><span class="line"><span class="comment">    if i == -1 &#123;</span></span><br><span class="line"><span class="comment">    return n</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    n++</span></span><br><span class="line"><span class="comment">    s = s[i+len(sep):]</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断a和b是否长度相同且包含相同字节。nil参数等效于空片</span></span><br><span class="line"><span class="comment">    *func Equal(a,b []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    return string(a) == string(b)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    EqualFold判断两个utf-8编码切片（将unicode大写、小写、标题三种格式字符视为相同）是否相同</span></span><br><span class="line"><span class="comment">    *func EqualFold(s,t []byte) bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Fields返回将字符串按照空白字符分割的多个子切片，若字符串全是空白或是空字符串的话，会返回空切片</span></span><br><span class="line"><span class="comment">    *func Fields(s []byte) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>,bytes.Fields([]bye(<span class="string">&quot;  foo bar  baz   &quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    FieldsFunc使用函数f确定分割符（满足f的utf-8码值），若字符串全部是分隔符或是空字符串的话，会返回空切片</span></span><br><span class="line"><span class="comment">    *func FieldsFunc(s []byte,f func(rune) bool) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>,bytes.FieldsFunc([]<span class="type">byte</span>(<span class="string">&quot;  foo1;bar2,baz3...&quot;</span>),f))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    HasPrefix测试字节片s是否以前缀开头，HasSuffix测试字节片s是否以后缀结尾</span></span><br><span class="line"><span class="comment">    *func HasPrefix(s,prefix []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    return len(s) &gt;= len(prefix) &amp;&amp; Equal(s[0:len(prefix)],prefix)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    *func HasSuffix(s,suffix []byte) bool &#123;</span></span><br><span class="line"><span class="comment">    return len(s) &gt;= len(suffix) &amp;&amp; Equal(s[len(s)-len(suffix):],suffix)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Index返回s中sep的第一个实例的索引；若s中不存在sep，则返回-1</span></span><br><span class="line"><span class="comment">    *func Index(s,sep []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Join将s的元素连接起来创建一个新的字节片，分隔符sep放置在所得切片中的元素之间</span></span><br><span class="line"><span class="comment">    *func Join(s [][]byte,sep []byte) []byte &#123;</span></span><br><span class="line"><span class="comment">    //若s无元素则返回空字节片</span></span><br><span class="line"><span class="comment">    if len(s) == 0 &#123;return []byte&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">    if len(s) == 1 &#123;return append([]byte(nil),s[0]...)&#125;</span></span><br><span class="line"><span class="comment">    n := len(sep) * (len(s) - 1)</span></span><br><span class="line"><span class="comment">    //计算所有元素和分隔符的字节总数</span></span><br><span class="line"><span class="comment">    for _,v := range s &#123;</span></span><br><span class="line"><span class="comment">    n += len(v)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    b := make([]byte,n)</span></span><br><span class="line"><span class="comment">    bp := copy(n,s[0])//记录连接位置</span></span><br><span class="line"><span class="comment">    for _,v := range s[1:] &#123;</span></span><br><span class="line"><span class="comment">    bp += copy(b[bp:],sep)</span></span><br><span class="line"><span class="comment">    bp += copy(b[bp:],v)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return b</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := [][]<span class="type">byte</span>&#123;[]<span class="type">byte</span>(<span class="string">&quot;foo&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;bar&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;baz&quot;</span>)&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, bytes.Join(s, []<span class="type">byte</span>(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LastIndex返回s中sep最后一个实例的索引：若s中不存在sep，则返回-1</span></span><br><span class="line"><span class="comment">    *func LastIndex(s,sep []byte) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(bytes.Index([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;go&quot;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LastIndexByte返回s中c的最后一个实例的索引；若s中不存在c则返回-1</span></span><br><span class="line"><span class="comment">    *func LastIndexByte(s []byte,c byte) int &#123;</span></span><br><span class="line"><span class="comment">    for i := len(s) - 1; i &gt;= 0; i-- &#123;</span></span><br><span class="line"><span class="comment">    if s[i] == c &#123;</span></span><br><span class="line"><span class="comment">    return i</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return -1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(bytes.LastIndexByte([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>), <span class="type">byte</span>(<span class="string">&#x27;g&#x27;</span>)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    返回count个b串联形成的新的切片</span></span><br><span class="line"><span class="comment">    *func Repeat(b []byte,count int) &#123;</span></span><br><span class="line"><span class="comment">    if count == 0 &#123;return []byte&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">    if count &lt; 0 &#123;</span></span><br><span class="line"><span class="comment">    panic(&quot;bytes: negative Repeat count&quot;)</span></span><br><span class="line"><span class="comment">    &#125;else if len(b)*count/count != len(b) &#123;</span></span><br><span class="line"><span class="comment">    panic(&quot;bytes: Repeat count causes overflow&quot;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    nb := make([]byte,len(b)*count)</span></span><br><span class="line"><span class="comment">    bp := copy(nb,b)</span></span><br><span class="line"><span class="comment">    for bp &lt; len(nb) &#123;</span></span><br><span class="line"><span class="comment">    copy(nb[bp:],nb[:bp])</span></span><br><span class="line"><span class="comment">    bp *= 2</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return nb</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;ba%s&quot;</span>, bytes.Repeat([]<span class="type">byte</span>(<span class="string">&quot;na&quot;</span>), <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Replace将返回slice的副本，其中有old的前n个非重叠实例被new取代，若old为空，则它在切片的开头和每个UTF-8序列之后匹配，最多产生k + 1个k - rune切片的替换；若n &lt; 0，则替换次数没有限制</span></span><br><span class="line"><span class="comment">    func Replace(s,old,new []byte,n int) []byte &#123;</span></span><br><span class="line"><span class="comment">    m := 0</span></span><br><span class="line"><span class="comment">    if n != 0 &#123;</span></span><br><span class="line"><span class="comment">    //计算s切片中有多少个old</span></span><br><span class="line"><span class="comment">    m = Count(s,old)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if m == 0 &#123;</span></span><br><span class="line"><span class="comment">    // Just return a copy</span></span><br><span class="line"><span class="comment">    return append([]byte(nil),s...)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //若要替换的数小于0或大于m则全替换</span></span><br><span class="line"><span class="comment">    if n &lt; 0 || m &lt; n &#123;</span></span><br><span class="line"><span class="comment">    n = m</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">            //计算缓冲区新切片总数</span></span><br><span class="line"><span class="comment">            t := make([]byte,len(s)+n*(len(new)-len(old)))</span></span><br><span class="line"><span class="comment">            w := 0</span></span><br><span class="line"><span class="comment">            start := 0</span></span><br><span class="line"><span class="comment">            for i := 0; i &lt; n; i++ &#123;</span></span><br><span class="line"><span class="comment">            j := start</span></span><br><span class="line"><span class="comment">            if len(old) == 0 &#123;</span></span><br><span class="line"><span class="comment">            if i &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">            _,wid := utf8.DecodeRune(s[start:])</span></span><br><span class="line"><span class="comment">            j += wid</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">            j += Index(s[start:],old)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            w += copy(t[w:],s[start:j])</span></span><br><span class="line"><span class="comment">            w += copy(t[w:],new)</span></span><br><span class="line"><span class="comment">            start = j + len(old)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            w += copy(t[w:],s[start:])</span></span><br><span class="line"><span class="comment">            return t[0:w]</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    func ReplaceAll(s, old, new []byte) []byte &#123;</span></span><br><span class="line"><span class="comment">    return Replace(s,old,new,-1)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, bytes.Replace([]<span class="type">byte</span>(<span class="string">&quot;oink oink oink&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;k&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;ky&quot;</span>), <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    符文将s解释为UTF-8编码的代码点序列。它返回与s等效的一片符文(Unicode代码点)</span></span><br><span class="line"><span class="comment">    func Runes(s []byte) []rune &#123;</span></span><br><span class="line"><span class="comment">    t := make([]rune,utf8.RuneCount(s))</span></span><br><span class="line"><span class="comment">    i := 0</span></span><br><span class="line"><span class="comment">    for len(s) &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">    r,l := utf8.DecodeRune(s)</span></span><br><span class="line"><span class="comment">    t[i] = r</span></span><br><span class="line"><span class="comment">    i++</span></span><br><span class="line"><span class="comment">    s = s[l:]</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">    return t</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rs := bytes.Runes([]<span class="type">byte</span>(<span class="string">&quot;go gopher&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> _,r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#U\n&quot;</span>,r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：</span></span><br><span class="line"><span class="comment">    U+0067 &#x27;g&#x27;</span></span><br><span class="line"><span class="comment">        U+006F &#x27;o&#x27;</span></span><br><span class="line"><span class="comment">        U+0020 &#x27; &#x27;</span></span><br><span class="line"><span class="comment">        U+0067 &#x27;g&#x27;</span></span><br><span class="line"><span class="comment">        U+006F &#x27;o&#x27;</span></span><br><span class="line"><span class="comment">        U+0070 &#x27;p&#x27;</span></span><br><span class="line"><span class="comment">        U+0068 &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">        U+0065 &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">        U+0072 &#x27;r&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将片段s分割为所有由sep分隔的子片段，返回这些分隔符之间的子片段的片段，若sep为空，则Split在每个UTF-8序列后拆分，它等效于SplitN，计数为-1</span></span><br><span class="line"><span class="comment">    func Split(s,sep []byte) [][]byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, bytes.Split([]<span class="type">byte</span>(<span class="string">&quot;a,b,c&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;,&quot;</span>)))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Trim通过切掉cutset中包含的所有前导和尾随UTF-8编码的代码点返回s的子片段</span></span><br><span class="line"><span class="comment">    func Trim(s []byte,cutset string) []byte</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%q]&quot;</span>, bytes.Trim([]<span class="type">byte</span>(<span class="string">&quot; !!! Achtung! Achtung! !!! &quot;</span>), <span class="string">&quot;! &quot;</span>))</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出：[&quot;Achtung! Achtung&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>轻量级的执行线程，多个goroutine比一个线程轻量，是go的基本执行单元；每个go程序至少有一个主goroutine（程序启动时自动创建）；使用方法类似其它语言的协程（coroutine）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello everybody&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> Hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Golang-Gorontine Example&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时并未执行Hello方法，main执行完后直接退出了，需要使用通道让Hello-Goroutine告诉main执行完成后退出</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>多个goroutine之间的沟通渠道，用于将结果、错误或任何信息从一个传递到另一个；通道是有类型的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello everybody&quot;</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> Hello(ch)</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;Golang-Gorontine Example&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当请求进来时，Handler创建一个监控goroutine并打印信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, SayHello) <span class="comment">// 设置访问的路由</span></span><br><span class="line">    log.Fatalln(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    fmt.Println(&amp;request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Current request is in progress&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, New Request Comes&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时假定请求耗时2s，在请求2s后返回，期望打印2次后立即停止，但运行发现，监控goroutine打印2次后仍不会结束且会一直打印；问题在创建监控goroutine后未对生命周期作控制；下面在打印前检测<code>request.Context()</code>是否已经结束，若结束则退出循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, SayHello) <span class="comment">// 设置访问的路由</span></span><br><span class="line"></span><br><span class="line">    log.Fatalln(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>,<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span>  &#123;</span><br><span class="line">    fmt.Println(&amp;request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;- request.Context().Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;request is outgoing&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Current request is in progress&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    writer.Write([]<span class="type">byte</span>(<span class="string">&quot;Hi, New Request Comes&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于如上需求，context包应运而生；<strong>context可以提供一个请求，从API请求边界到各goroutine请求域数据传递、取消信号及截止时间等能力</strong></p><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>Go中每一个请求都是通过一个单独的Goroutine进行处理的，HTTP&#x2F;RPC请求处理器往往会启动新的Goroutine访问数据库和RPC服务，可能会创建多个来处理一次请求；Context的主要作用即在不同Goroutine间同步请求特定的数据、取消信号以及处理请求的截止日期</p><h4 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;- <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deadline方法需要返回当前Context被取消的时间，即完成工作的截止时间</span></span><br><span class="line"><span class="comment">// Done方法返回一个Channel，该Channel会在当前工作完成或上下文被取消后关闭，多次调用该方法会返回同一个Channel</span></span><br><span class="line"><span class="comment">// Err方法返回Context结束的原因，只会在Done返回的Channel被关闭时才会返回非空的值</span></span><br><span class="line"><span class="comment">// 若当前Context被取消就会返回Canceled错误</span></span><br><span class="line"><span class="comment">// 若当前Context超时就会返回DeadlineExceed错误</span></span><br><span class="line"><span class="comment">// Value方法从Context中返回键对应的值对于同一个上下文来说，多次调用Value 并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域：若a页面想获取b页面资源，但它们的协议、域名、端口、子域名不同；则所进行的访问行动都是跨域的（跨域限制访问其实是浏览器的限制）</span></span><br><span class="line"><span class="comment">// 跨域问题解决：用nginx作为代理服务器只在80端口交互</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go内置两个函数：Background()和TODO()，这两个函数分别返回一个实现了Context接口的background和todo;</span></span><br><span class="line"><span class="comment">// Background()主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context</span></span><br><span class="line"><span class="comment">// TODO()，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个</span></span><br><span class="line"><span class="comment">// background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h5><p>此外，<code>context</code>包中还定义了四个With系列函数；这些函数返回的都是实现了上述接口方法的对应结构体</p><p><img src="https://s1.ax1x.com/2023/02/15/pS7P1MD.png"></p><h6 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h6><p>接受一个Context并返回其子Context和取消函数cancel</p><p>新创建协程中传入子Context做参数且监控其Done通道，若收到消息则退出</p><p>需要新协程结束时在外调用cancel函数，即会往子Context的Done通道发送消息</p><p>当父Context的Done()关闭时，子ctx的Done()也会被关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用根context创建一个父context，并使用其创建一个协程</span></span><br><span class="line"><span class="comment">// 再由父创建一个子context，再使用该子context创建一个协程</span></span><br><span class="line"><span class="comment">// 一段时间后调用父context的cancel函数发现父和子协程都收到信号结束了</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 父context(利用根context得到)</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父context的子协程</span></span><br><span class="line"><span class="keyword">go</span> watch1(ctx)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context，注意：这里虽然也返回了cancel的函数对象，但是未使用</span></span><br><span class="line">valueCtx, _ := context.WithCancel(ctx)</span><br><span class="line"><span class="comment">// 子context的子协程</span></span><br><span class="line"><span class="keyword">go</span> watch2(valueCtx)</span><br><span class="line"> </span><br><span class="line">fmt.Println(<span class="string">&quot;现在开始等待3秒,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用cancel()</span></span><br><span class="line">fmt.Println(<span class="string">&quot;等待3秒结束,调用cancel()函数&quot;</span>)</span><br><span class="line">cancel()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再等待5秒看输出，可以发现父context的子协程和子context的子协程都会被结束掉</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;最终结束,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch1</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">fmt.Println(<span class="string">&quot;收到信号，父context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;父context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子context的协程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//取出值即说明是结束信号</span></span><br><span class="line">fmt.Println(<span class="string">&quot;收到信号，子context的协程退出,time=&quot;</span>, time.Now().Unix())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;子context的协程监控中,time=&quot;</span>, time.Now().Unix())</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// withCancel的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">c := newCancelCtx(parent)   <span class="comment">//返回一个cancelCtx结构体</span></span><br><span class="line">propagateCancel(parent, &amp;c)   <span class="comment">//绑定父子context关系</span></span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context   <span class="comment">// 自己的父context</span></span><br><span class="line"></span><br><span class="line">mu       sync.Mutex</span><br><span class="line">done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// 接收取消信号的管道</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 包含自己路径下所有子context集合</span></span><br><span class="line">err      <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ctx.Done()其实就是一个管道，即上面cancelCtx结构体中的done</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">d := c.done</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="WithTimeout、WithDeadline"><a href="#WithTimeout、WithDeadline" class="headerlink" title="WithTimeout、WithDeadline"></a>WithTimeout、WithDeadline</h6><p><code>WithTimeout</code>底层实现是调用的<code>WithDeadline</code>，并添加对应的过期时间</p><p><code>WithDeadline</code>即添加了<code>timer</code>计时器，<code>time.AfterFunc</code>中计时条件满足时自动触发<code>cancel</code>函数</p><h6 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h6><p>返回一个带有键值对的<code>valueCtx</code>结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span>&#123;&#125;<span class="comment">//数据库操作句柄，代表一个具有零到多个底层连接的连接池，可以安全的被多个go程同时使用；sql包会自动创建和释放连接，也会维护一个闲置连接的连接池；连接池的大小可用SetMaxldleConns方法控制</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName,dataSourceName <span class="type">string</span>)</span></span> (*DB,<span class="type">error</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">driverName表示driver名称，dataSourceName表示连接数据库的信息；</span></span><br><span class="line"><span class="comment">Open函数只验证其参数，不创建与数据库的连接，若要检查数据源的名称是否合法，应调用返回值的Ping方法；Open函数只需调用一次，很少需要关闭DB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Ping() <span class="type">error</span></span><br><span class="line"><span class="comment">// 检查与数据库的连接是否有效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Close() <span class="type">error</span></span><br><span class="line"><span class="comment">// 关闭数据库，释放任何打开的资源，一般不关闭DB，DB句柄通常被多个go程共享，并长期活跃</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// Exec执行一次命令（包括查询、删除、更新、插入等），不返回任何执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span></span> Query(query <span class="type">string</span>,args ...<span class="keyword">interface</span>&#123;&#125;) (*Rows,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// Query执行一次查询，返回多行结果，一般用于执行select命令</span></span><br><span class="line">    age := <span class="number">27</span></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;SELECT name FROM users WHERE age=?&quot;</span>, age)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        <span class="keyword">if</span> err := rows.Scan(&amp;name); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s is %d\n&quot;</span>, name, age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> QueryRow(query <span class="type">string</span>,args ...<span class="keyword">interface</span>&#123;&#125;) *Row</span><br><span class="line"><span class="comment">// QueryRow执行一次查询并期望返回最多一行结果；QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时才会返回被延迟的错误</span></span><br><span class="line">    id := <span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> username <span class="type">string</span></span><br><span class="line">    err := db.QueryRow(<span class="string">&quot;SELECT username FROM users WHERE id=?&quot;</span>, id).Scan(&amp;username)</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> err == sql.ErrNoRows:</span><br><span class="line">        log.Printf(<span class="string">&quot;No user with that ID.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Username is %s\n&quot;</span>, username)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*DB)</span></span> Begin() (*Tx,<span class="type">error</span>)</span><br><span class="line"><span class="comment">// 开始一个事务</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rs *Rows)</span></span> Next() <span class="type">bool</span></span><br><span class="line"><span class="comment">// 用于Scan方法的下一行结果，若成功返回真，若没有下一行或出现错误返回假</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p><code>struct tag</code>可以决定<code>Marshal</code>和<code>Unmarshal</code>函数如何序列化和反序列化数据</p><h5 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h5><p><code>func Marshal(v interface&#123;&#125;) ([]byte, error)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColorGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="type">int</span></span><br><span class="line">    Name   <span class="type">string</span></span><br><span class="line">    Colors []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">group := ColorGroup&#123;</span><br><span class="line">    ID:     <span class="number">1</span>,</span><br><span class="line">    Name:   <span class="string">&quot;Reds&quot;</span>,</span><br><span class="line">    Colors: []<span class="type">string</span>&#123;<span class="string">&quot;Crimson&quot;</span>, <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Ruby&quot;</span>, <span class="string">&quot;Maroon&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">b, err := json.Marshal(group)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">os.Stdout.Write(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: &#123;&quot;ID&quot;:1,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Unmarshal"><a href="#Unmarshal" class="headerlink" title="Unmarshal"></a>Unmarshal</h5><p><code>func Unmarshal(data []byte, v interface&#123;&#125;) error</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonBlob = []<span class="type">byte</span>(<span class="string">`[</span></span><br><span class="line"><span class="string">&#123;&quot;Name&quot;: &quot;Platypus&quot;, &quot;Order&quot;: &quot;Monotremata&quot;&#125;,</span></span><br><span class="line"><span class="string">&#123;&quot;Name&quot;: &quot;Quoll&quot;,    &quot;Order&quot;: &quot;Dasyuromorphia&quot;&#125;</span></span><br><span class="line"><span class="string">]`</span>)</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Order <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animals []Animal</span><br><span class="line">err := json.Unmarshal(jsonBlob, &amp;animals)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, animals)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: [&#123;Name:Platypus Order:Monotremata&#125; &#123;Name:Quoll Order:Dasyuromorphia&#125;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>实现了类似C语言<code>printf</code>和<code>scanf</code>的格式化I&#x2F;O</p><h4 id="类型格式"><a href="#类型格式" class="headerlink" title="类型格式"></a>类型格式</h4><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%v值的默认格式表示</span><br><span class="line">%+v类似%v，但输出结构体时会添加字段名</span><br><span class="line">%#v值的go语法表示</span><br><span class="line">%T值的类型的go语法表示</span><br><span class="line">%%百分号</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%t单词true或false</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%b表示为二进制</span><br><span class="line">%c该值对应的unicode码值</span><br><span class="line">%d表示为十进制</span><br><span class="line">%o表示为八进制</span><br><span class="line">%q该值对应的单引号括起来的go语法字符字面值，必要时采用安全的转义表示</span><br><span class="line">%x表示为十六进制，使用a-f</span><br><span class="line">%X表示为十六进制，使用A-F</span><br><span class="line">%U表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%b无小数部分、二进制指数的科学计数法，如-123456p-78;</span><br><span class="line">%e科学计数法，如-1234.456e+78</span><br><span class="line">%E科学计数法，如-1234.456E+78</span><br><span class="line">%f有小数部分但无指数部分，如123.456（在后面加入小数，个位表示宽度，小数位表示精度）</span><br><span class="line">%F等价于%f</span><br><span class="line">%g根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span><br><span class="line">%G根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="字符串与-byte"><a href="#字符串与-byte" class="headerlink" title="字符串与[]byte"></a>字符串与[]byte</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%s直接输出字符串或者[]byte</span><br><span class="line">%q该值对应双引号括起来的go语法字符串字面值，必要时采用安全的转义表示</span><br><span class="line">%x每个字节用两字符十六进制数表示（使用a-f）</span><br><span class="line">%X每个字节用两字符十六进制数表示（使用A-F）    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%p表示为十六进制，并加上前导的0x    </span><br><span class="line">fmt.Sprintf(&quot;%[2]d %[1]d\n&quot;, 11, 22)//会生成&quot;22 11&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="向外输出"><a href="#向外输出" class="headerlink" title="向外输出"></a>向外输出</h4><h5 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接输出内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//支持格式化输出字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>,a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"><span class="comment">//在输出内容结尾添加一个换行符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>,err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;名字是：%v\n&quot;</span>,<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;年龄是：%v\n&quot;</span>,<span class="number">19</span>)</span><br><span class="line">p:= <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;lxx&quot;</span>,<span class="number">19</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为：%v\n&quot;</span>,p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为(带字段名)：%+v\n&quot;</span>,p) <span class="comment">// 输出结构体是会带name</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;结构体内容为(值的Go语法表示)：%#v\n&quot;</span>,p) <span class="comment">// 输出结构体是会带name</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;切片内容为：%v\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;切片内容为(值的Go语法表示)：%#v\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;切片值的类型为：%T\n&quot;</span>,[]<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串值的类型为：%T\n&quot;</span>,<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;打印百分百：100%%\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//名字是：lxx</span></span><br><span class="line"><span class="comment">//年龄是：19</span></span><br><span class="line"><span class="comment">//结构体内容为：&#123;lxx 19&#125;</span></span><br><span class="line"><span class="comment">//结构体内容为(带字段名)：&#123;name:lxx age:19&#125;</span></span><br><span class="line"><span class="comment">//结构体内容为(值的Go语法表示)：struct &#123; name string; age int &#125;&#123;name:&quot;lxx&quot;, age:19&#125;</span></span><br><span class="line"><span class="comment">//切片内容为：[4 5 6]</span></span><br><span class="line"><span class="comment">//切片内容为(值的Go语法表示)：[]int&#123;4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//切片值的类型为：[]int</span></span><br><span class="line"><span class="comment">//字符串值的类型为：string</span></span><br><span class="line"><span class="comment">//打印百分百：100%</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h5><p>将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，通常用该函数往文件中写入内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//向标准输出写入内容</span></span><br><span class="line">    fmt.Fprint(os.Stdout,<span class="string">&quot;向标准输出（控制台）写入内容&quot;</span>)</span><br><span class="line">    fileObj,err := os.OpenFile(<span class="string">&quot;./xx.txt&quot;</span>,os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    name := <span class="string">&quot;lxx is nb&quot;</span></span><br><span class="line">    <span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.Fprintf(fileObj, <span class="string">&quot;往文件中(标准输出)写如信息：%s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h5><p>将传入的数据生成并返回一个字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line">s1 := fmt.Sprint(<span class="string">&quot;lxx&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;lxx&quot;</span></span><br><span class="line">age := <span class="number">18</span></span><br><span class="line">s2 := fmt.Sprintf(<span class="string">&quot;姓名:%s,年龄:%d&quot;</span>, name, age)</span><br><span class="line">s3 := fmt.Sprintln(<span class="string">&quot;lxx is nb&quot;</span>)</span><br><span class="line">fmt.Println(s1, s2, s3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: lxx 姓名:lxx,年龄:18 lxx is nb</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h4><h5 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h5><ul><li>从标准输入扫描文本，读取由空白字符分隔的值保存到传递给本函数的参数中，换行符视为空白符</li><li>返回成功扫描的数据个数和遇到的任何错误，若读取数据个数比提供的参数少，会返回一个错误报告原因</li><li><strong>若想完整获取输入的内容，而输入的内容可能包含空格，可以使用<code>bufio</code>中的方法</strong></li></ul><p><code>func Scan(a ...interface&#123;&#125;) (n int,err error)</code></p><h5 id="Scanf"><a href="#Scanf" class="headerlink" title="Scanf"></a>Scanf</h5><p><code>func Scanf(format string, a ...interface&#123;&#125;) (n int, err error)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;name:%s age:%d&quot;</span>, &amp;name, &amp;age) <span class="comment">// 在控制台按照该格式输入</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;扫描结果： 姓名:%s 年龄:%d \n&quot;</span>, name, age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台按如下格式输入</span></span><br><span class="line"><span class="comment">//name:lxx age:19</span></span><br><span class="line"><span class="comment">//扫描结果： 姓名:lxx 年龄:19 </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Scanln"><a href="#Scanln" class="headerlink" title="Scanln"></a>Scanln</h5><p>类似Scan，遇到换行时才停止扫描</p><p><code>func Scanln(a ...interface&#123;&#125;) (n int, err error)</code></p><h5 id="Fscan和Sscan"><a href="#Fscan和Sscan" class="headerlink" title="Fscan和Sscan"></a>Fscan和Sscan</h5><p>Fscan从<code>io.Reader</code>中读取数据，Sscan从指定字符串中读取数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="type">string</span>, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span>=<span class="string">&quot;lxx&quot;</span></span><br><span class="line"><span class="keyword">var</span> newName <span class="type">string</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">fmt.Sscan(name,&amp;newName) <span class="comment">// 相当于把name的值赋值给newName</span></span><br><span class="line">fmt.Println(name)</span><br><span class="line">fmt.Println(newName)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="strings-和-strconv"><a href="#strings-和-strconv" class="headerlink" title="strings 和 strconv"></a>strings 和 strconv</h3><p>对于字符串的预定义处理函数</p><h4 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h4><p><code>HasPrefix()</code>判断字符串<code>s</code>是否以<code>prefix</code>开头</p><p><code>HasSuffix()</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">strings.HasSuffix(s, suffix <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h4><p><code>Contains()</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Index()</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(s, str <span class="type">string</span>) <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>LastIndex()</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中最后出现位置的索引（<code>str</code> 的第一个字符的索引），<code>-1</code> 表示字符串 <code>s</code> 不包含字符串 <code>str</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="type">string</span>) <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若要查询非 ASCII 编码的字符在父字符串中的位置，建议使用以下函数定位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.IndexRune(s <span class="type">string</span>, r <span class="type">rune</span>) <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p><code>Replace()</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并返回一个新的字符串，如果 <code>n = -1</code> 则替换所有字符串 <code>old</code> 为字符串 <code>new</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span> <span class="type">string</span>, n <span class="type">int</span>) <span class="type">string</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字符串出现次数"><a href="#字符串出现次数" class="headerlink" title="字符串出现次数"></a>字符串出现次数</h4><p><code>Count()</code> 用于计算字符串 <code>str</code> 在字符串 <code>s</code> 中出现的非重叠次数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Count(s, str <span class="type">string</span>) <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h4><p><code>Repeat()</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="type">int</span>) <span class="type">string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h4><p><code>ToLower()</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符</p><p><code>ToUpper()</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.ToLower(s) <span class="type">string</span></span><br><span class="line">strings.ToUpper(s) <span class="type">string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h4><p>使用 <code>strings.TrimSpace(s)</code> 来剔除字符串开头和结尾的空白符号；若想剔除指定字符，可以使用 <code>strings.Trim(s, &quot;cut&quot;)</code> 来将开头和结尾的 <code>cut</code> 去除掉。该函数的第二个参数可以包含任何字符，若只想剔除开头或者结尾的字符串，则可以使用 <code>TrimLeft()</code> 或者 <code>TrimRight()</code> 来实现</p><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>strings.Fields(s)</code> 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice</p><p><code>strings.Split(s, sep)</code> 用于自定义分割符号进行分割，同样返回 slice</p><p>因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理</p><h4 id="拼接slice到字符串"><a href="#拼接slice到字符串" class="headerlink" title="拼接slice到字符串"></a>拼接slice到字符串</h4><p><code>Join()</code> 用于将元素类型为 string 的 slice 用分割符号来拼接组成一个字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strings.Join(sl []<span class="type">string</span>, sep <span class="type">string</span>) <span class="type">string</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h4><p> <code>strings.NewReader(str)</code> 用于生成一个 <code>Reader</code> 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其它类型读取内容的函数还有：</p><ul><li><code>Read()</code> 从 <code>[]byte</code> 中读取内容</li><li><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 <code>byte</code> 或者 <code>rune</code></li></ul><h4 id="字符串与其它类型的转换"><a href="#字符串与其它类型的转换" class="headerlink" title="字符串与其它类型的转换"></a>字符串与其它类型的转换</h4><p>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的，任何类型<code>T</code>转换为字符串总是成功的</p><p>针对从数字类型转换到字符串，Go 提供了以下函数：</p><ul><li><code>strconv.Itoa(i int) string</code> 返回数字 <code>i</code> 表示的字符串类型的十进制数</li><li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code>将 64 位浮点型的数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>&#39;b&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;f&#39;</code> 或 <code>&#39;g&#39;</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 <code>float32</code>，用 64 表示 <code>float64</code></li></ul><p>针对从字符串类型转换为数字类型，Go 提供了以下函数：</p><ul><li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 <code>int</code> 型</li><li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 <code>float64</code> 型</li></ul><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func Copy(dst Writer, src Reader) (written int64, err error)</span></span><br><span class="line"><span class="comment">func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</span></span><br><span class="line"><span class="comment">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</span></span><br><span class="line"><span class="comment">func Pipe() (*PipeReader, *PipeWriter)</span></span><br><span class="line"><span class="comment">func ReadAll(r Reader) ([]byte, error)</span></span><br><span class="line"><span class="comment">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</span></span><br><span class="line"><span class="comment">func ReadFull(r Reader, buf []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func WriteString(w Writer, s string) (n int, err error)</span></span><br><span class="line"><span class="comment">type ByteReader</span></span><br><span class="line"><span class="comment">type ByteScanner</span></span><br><span class="line"><span class="comment">type ByteWriter</span></span><br><span class="line"><span class="comment">type Closer</span></span><br><span class="line"><span class="comment">type LimitedReader</span></span><br><span class="line"><span class="comment">func (l *LimitedReader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type PipeReader</span></span><br><span class="line"><span class="comment">func (r *PipeReader) Close() error</span></span><br><span class="line"><span class="comment">func (r *PipeReader) CloseWithError(err error) error</span></span><br><span class="line"><span class="comment">func (r *PipeReader) Read(data []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type PipeWriter</span></span><br><span class="line"><span class="comment">func (w *PipeWriter) Close() error</span></span><br><span class="line"><span class="comment">func (w *PipeWriter) CloseWithError(err error) error</span></span><br><span class="line"><span class="comment">func (w *PipeWriter) Write(data []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">type ReadCloser</span></span><br><span class="line"><span class="comment">func NopCloser(r Reader) ReadCloser</span></span><br><span class="line"><span class="comment">type ReadSeekCloser</span></span><br><span class="line"><span class="comment">type ReadSeeker</span></span><br><span class="line"><span class="comment">type ReadWriteCloser</span></span><br><span class="line"><span class="comment">type ReadWriteSeeker</span></span><br><span class="line"><span class="comment">type ReadWriter</span></span><br><span class="line"><span class="comment">type Reader</span></span><br><span class="line"><span class="comment">func LimitReader(r Reader, n int64) Reader</span></span><br><span class="line"><span class="comment">func MultiReader(readers ...Reader) Reader</span></span><br><span class="line"><span class="comment">func TeeReader(r Reader, w Writer) Reader</span></span><br><span class="line"><span class="comment">type ReaderAt</span></span><br><span class="line"><span class="comment">type ReaderFrom</span></span><br><span class="line"><span class="comment">type RuneReader</span></span><br><span class="line"><span class="comment">type RuneScanner</span></span><br><span class="line"><span class="comment">type SectionReader</span></span><br><span class="line"><span class="comment">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</span></span><br><span class="line"><span class="comment">func (s *SectionReader) Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</span></span><br><span class="line"><span class="comment">func (s *SectionReader) Size() int64</span></span><br><span class="line"><span class="comment">type Seeker</span></span><br><span class="line"><span class="comment">type StringWriter</span></span><br><span class="line"><span class="comment">type WriteCloser</span></span><br><span class="line"><span class="comment">type WriteSeeker</span></span><br><span class="line"><span class="comment">type Writer</span></span><br><span class="line"><span class="comment">func MultiWriter(writers ...Writer) Writer</span></span><br><span class="line"><span class="comment">type WriterAt</span></span><br><span class="line"><span class="comment">type WriterTo</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *func Copy(dst Writer,src Reader) (written int64,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;some io.Reader stream to be read&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(os.Stdout, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *func Pipe() (*PipeReader,*PipeWriter)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    r,w := io.Pipe()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w,<span class="string">&quot;some io.Reader stream to be read\n&quot;</span>)</span><br><span class="line">        w.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> _,err := io.Copy(os.Stdout,r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="log（提供日志操作的函数和方法）"><a href="#log（提供日志操作的函数和方法）" class="headerlink" title="log（提供日志操作的函数和方法）"></a>log（提供日志操作的函数和方法）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">func Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Fatalf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Fatalln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Flags() int</span></span><br><span class="line"><span class="comment">func Output(calldepth int, s string) error</span></span><br><span class="line"><span class="comment">func Panic(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Panicf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Panicln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Prefix() string</span></span><br><span class="line"><span class="comment">func Print(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Printf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func Println(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func SetFlags(flag int)</span></span><br><span class="line"><span class="comment">func SetOutput(w io.Writer)</span></span><br><span class="line"><span class="comment">func SetPrefix(prefix string)</span></span><br><span class="line"><span class="comment">func Writer() io.Writer</span></span><br><span class="line"><span class="comment">type Logger</span></span><br><span class="line"><span class="comment">func Default() *Logger</span></span><br><span class="line"><span class="comment">func New(out io.Writer, prefix string, flag int) *Logger</span></span><br><span class="line"><span class="comment">func (l *Logger) Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Fatalf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Fatalln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Flags() int</span></span><br><span class="line"><span class="comment">func (l *Logger) Output(calldepth int, s string) error</span></span><br><span class="line"><span class="comment">func (l *Logger) Panic(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Panicf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Panicln(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Prefix() string</span></span><br><span class="line"><span class="comment">func (l *Logger) Print(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Printf(format string, v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) Println(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">func (l *Logger) SetFlags(flag int)</span></span><br><span class="line"><span class="comment">func (l *Logger) SetOutput(w io.Writer)</span></span><br><span class="line"><span class="comment">func (l *Logger) SetPrefix(prefix string)</span></span><br><span class="line"><span class="comment">func (l *Logger) Writer() io.Writer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Print类：跟fmt差不多，只是前面加了格式</span></span><br><span class="line">    <span class="comment">// Fatal类：日志输出后，系统调用os.exit(1)，整个程序退出，若后面有defer，也不执行</span></span><br><span class="line">    <span class="comment">// Panic类：日志输出后，发生Panic</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Fatal等价于&#123;Print(v...);os.Exit(1)&#125;</span></span><br><span class="line"><span class="comment">    *func Fatal(v ...interface&#123;&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.Fatal(<span class="string">&quot;hello啊树先生，执行后终止&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;你执行了吗？&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SetFlags设置标准logger的输出选项</span></span><br><span class="line"><span class="comment">    *func SetFlags(flag int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.SetFlags(log.Ldate|log.Ltime|log.LUTC)</span><br><span class="line">    log.Println(<span class="string">&quot;sddfgfgh&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SetOutput设置标准logger的输出目的地，默认是标准错误输出</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    file,_ := os.Create(<span class="string">&quot;sdk/testLog&quot;</span>)</span><br><span class="line">    log.SetOutput(file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sort（按照一定规则对元素进行相关排序）"><a href="#sort（按照一定规则对元素进行相关排序）" class="headerlink" title="sort（按照一定规则对元素进行相关排序）"></a>sort（按照一定规则对元素进行相关排序）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func Float64s(x []float64)</span></span><br><span class="line"><span class="comment">func Float64sAreSorted(x []float64) bool</span></span><br><span class="line"><span class="comment">func Ints(x []int)</span></span><br><span class="line"><span class="comment">func IntsAreSorted(x []int) bool</span></span><br><span class="line"><span class="comment">func IsSorted(data Interface) bool</span></span><br><span class="line"><span class="comment">func Search(n int, f func(int) bool) int</span></span><br><span class="line"><span class="comment">func SearchFloat64s(a []float64, x float64) int</span></span><br><span class="line"><span class="comment">func SearchInts(a []int, x int) int</span></span><br><span class="line"><span class="comment">func SearchStrings(a []string, x string) int</span></span><br><span class="line"><span class="comment">func Slice(x interface&#123;&#125;, less func(i, j int) bool)</span></span><br><span class="line"><span class="comment">func SliceIsSorted(x interface&#123;&#125;, less func(i, j int) bool) bool</span></span><br><span class="line"><span class="comment">func SliceStable(x interface&#123;&#125;, less func(i, j int) bool)</span></span><br><span class="line"><span class="comment">func Sort(data Interface)</span></span><br><span class="line"><span class="comment">func Stable(data Interface)</span></span><br><span class="line"><span class="comment">func Strings(x []string)</span></span><br><span class="line"><span class="comment">func StringsAreSorted(x []string) bool</span></span><br><span class="line"><span class="comment">type Float64Slice</span></span><br><span class="line"><span class="comment">func (x Float64Slice) Len() int</span></span><br><span class="line"><span class="comment">func (x Float64Slice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">func (p Float64Slice) Search(x float64) int</span></span><br><span class="line"><span class="comment">func (x Float64Slice) Sort()</span></span><br><span class="line"><span class="comment">func (x Float64Slice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">type IntSlice</span></span><br><span class="line"><span class="comment">func (x IntSlice) Len() int</span></span><br><span class="line"><span class="comment">func (x IntSlice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">func (p IntSlice) Search(x int) int</span></span><br><span class="line"><span class="comment">func (x IntSlice) Sort()</span></span><br><span class="line"><span class="comment">func (x IntSlice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">type Interface</span></span><br><span class="line"><span class="comment">func Reverse(data Interface) Interface</span></span><br><span class="line"><span class="comment">type StringSlice</span></span><br><span class="line"><span class="comment">func (x StringSlice) Len() int</span></span><br><span class="line"><span class="comment">func (x StringSlice) Less(i, j int) bool</span></span><br><span class="line"><span class="comment">func (p StringSlice) Search(x string) int</span></span><br><span class="line"><span class="comment">func (x StringSlice) Sort()</span></span><br><span class="line"><span class="comment">func (x StringSlice) Swap(i, j int)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Float64s按递增顺序对float64s的一部分进行排序，Not-a-number(NaN)值先于其他值排序</span></span><br><span class="line"><span class="comment">    *func Float64s(x []float64)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">float64</span>&#123;math.Inf(<span class="number">1</span>), math.NaN(), math.Inf(<span class="number">-1</span>), <span class="number">0.0</span>&#125;</span><br><span class="line">sort.Float64s(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">    <span class="comment">/*输出：[NaN -Inf 0 +Inf]*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Float64sAreSorted报告切片x是否以递增的顺序排序，其中not-a-number(NaN)值位于任何其他值之前</span></span><br><span class="line"><span class="comment">    *func Float64sAreSorted(x []float64) bool</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Search使用二分法进行查找</span></span><br><span class="line"><span class="comment">    *func Search(n int,f func(int) bool) int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>,<span class="number">55</span>&#125;</span><br><span class="line">    x := <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">    i := sort.Search(<span class="built_in">len</span>(a),<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> a[i] &gt;= x&#125;)</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; a[i] == x &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;found %d at index %d in %v\n&quot;</span>, x, i, a)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d not found in %v\n&quot;</span>, x, a)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    返回x在a中应该存在的位置，无论a中是否存在a中在递增顺序的a中搜索x，返回x的索引。如果查找不到，返回值是x应该插入a的位置（以保证a的递增顺序），返回值可以是len(a)</span></span><br><span class="line"><span class="comment">    *func SearchInts(a []int,x int) int&#123;</span></span><br><span class="line"><span class="comment">    return Search(len(a),func(i int) bool &#123;return a[i]&gt;=x&#125;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;</span><br><span class="line">index := sort.SearchInts(s, <span class="number">5</span>)</span><br><span class="line">fmt.Println(index)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符串按升序对字符串的一部分进行排序</span></span><br><span class="line"><span class="comment">    *func Strings(x []string)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s := []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Bravo&quot;</span>, <span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Alpha&quot;</span>, <span class="string">&quot;Grin&quot;</span>, <span class="string">&quot;Delta&quot;</span>&#125;</span><br><span class="line">sort.Strings(s)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    求FloatSlice的数据类型的长度</span></span><br><span class="line"><span class="comment">    *func (x Float64Slice) Len() int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> x sort.Float64Slice</span><br><span class="line">x = []<span class="type">float64</span>&#123;<span class="number">74.3</span>, <span class="number">59.0</span>, math.Inf(<span class="number">1</span>), <span class="number">238.2</span>, <span class="number">-784.0</span>, <span class="number">2.3</span>, math.NaN(), math.NaN(), </span><br><span class="line">        math.Inf(<span class="number">-1</span>), <span class="number">9845.768</span>, <span class="number">-959.7485</span>, <span class="number">905</span>, <span class="number">7.8</span>, <span class="number">7.8</span>&#125;</span><br><span class="line">fmt.Println(x.Len())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OS（底层相关的函数和方法）"><a href="#OS（底层相关的函数和方法）" class="headerlink" title="OS（底层相关的函数和方法）"></a>OS（底层相关的函数和方法）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func Chdir(dir string) error</span></span><br><span class="line"><span class="comment">func Chmod(name string, mode FileMode) error</span></span><br><span class="line"><span class="comment">func Chown(name string, uid, gid int) error</span></span><br><span class="line"><span class="comment">func Chtimes(name string, atime time.Time, mtime time.Time) error</span></span><br><span class="line"><span class="comment">func Clearenv()</span></span><br><span class="line"><span class="comment">func DirFS(dir string) fs.FS</span></span><br><span class="line"><span class="comment">func Environ() []string</span></span><br><span class="line"><span class="comment">func Executable() (string, error)</span></span><br><span class="line"><span class="comment">func Exit(code int)</span></span><br><span class="line"><span class="comment">func Expand(s string, mapping func(string) string) string</span></span><br><span class="line"><span class="comment">func ExpandEnv(s string) string</span></span><br><span class="line"><span class="comment">func Getegid() int</span></span><br><span class="line"><span class="comment">func Getenv(key string) string</span></span><br><span class="line"><span class="comment">func Geteuid() int</span></span><br><span class="line"><span class="comment">func Getgid() int</span></span><br><span class="line"><span class="comment">func Getgroups() ([]int, error)</span></span><br><span class="line"><span class="comment">func Getpagesize() int</span></span><br><span class="line"><span class="comment">func Getpid() int</span></span><br><span class="line"><span class="comment">func Getppid() int</span></span><br><span class="line"><span class="comment">func Getuid() int</span></span><br><span class="line"><span class="comment">func Getwd() (dir string, err error)</span></span><br><span class="line"><span class="comment">func Hostname() (name string, err error)</span></span><br><span class="line"><span class="comment">func IsExist(err error) bool</span></span><br><span class="line"><span class="comment">func IsNotExist(err error) bool</span></span><br><span class="line"><span class="comment">func IsPathSeparator(c uint8) bool</span></span><br><span class="line"><span class="comment">func IsPermission(err error) bool</span></span><br><span class="line"><span class="comment">func IsTimeout(err error) bool</span></span><br><span class="line"><span class="comment">func Lchown(name string, uid, gid int) error</span></span><br><span class="line"><span class="comment">func Link(oldname, newname string) error</span></span><br><span class="line"><span class="comment">func LookupEnv(key string) (string, bool)</span></span><br><span class="line"><span class="comment">func Mkdir(name string, perm FileMode) error</span></span><br><span class="line"><span class="comment">func MkdirAll(path string, perm FileMode) error</span></span><br><span class="line"><span class="comment">func MkdirTemp(dir, pattern string) (string, error)</span></span><br><span class="line"><span class="comment">func NewSyscallError(syscall string, err error) error</span></span><br><span class="line"><span class="comment">func Pipe() (r *File, w *File, err error)</span></span><br><span class="line"><span class="comment">func ReadFile(name string) ([]byte, error)</span></span><br><span class="line"><span class="comment">func Readlink(name string) (string, error)</span></span><br><span class="line"><span class="comment">func Remove(name string) error</span></span><br><span class="line"><span class="comment">func RemoveAll(path string) error</span></span><br><span class="line"><span class="comment">func Rename(oldpath, newpath string) error</span></span><br><span class="line"><span class="comment">func SameFile(fi1, fi2 FileInfo) bool</span></span><br><span class="line"><span class="comment">func Setenv(key, value string) error</span></span><br><span class="line"><span class="comment">func Symlink(oldname, newname string) error</span></span><br><span class="line"><span class="comment">func TempDir() string</span></span><br><span class="line"><span class="comment">func Truncate(name string, size int64) error</span></span><br><span class="line"><span class="comment">func Unsetenv(key string) error</span></span><br><span class="line"><span class="comment">func UserCacheDir() (string, error)</span></span><br><span class="line"><span class="comment">func UserConfigDir() (string, error)</span></span><br><span class="line"><span class="comment">func UserHomeDir() (string, error)</span></span><br><span class="line"><span class="comment">func WriteFile(name string, data []byte, perm FileMode) error</span></span><br><span class="line"><span class="comment">type DirEntry</span></span><br><span class="line"><span class="comment">func ReadDir(name string) ([]DirEntry, error)</span></span><br><span class="line"><span class="comment">type File</span></span><br><span class="line"><span class="comment">func Create(name string) (*File, error)</span></span><br><span class="line"><span class="comment">func CreateTemp(dir, pattern string) (*File, error)</span></span><br><span class="line"><span class="comment">func NewFile(fd uintptr, name string) *File</span></span><br><span class="line"><span class="comment">func Open(name string) (*File, error)</span></span><br><span class="line"><span class="comment">func OpenFile(name string, flag int, perm FileMode) (*File, error)</span></span><br><span class="line"><span class="comment">func (f *File) Chdir() error</span></span><br><span class="line"><span class="comment">func (f *File) Chmod(mode FileMode) error</span></span><br><span class="line"><span class="comment">func (f *File) Chown(uid, gid int) error</span></span><br><span class="line"><span class="comment">func (f *File) Close() error</span></span><br><span class="line"><span class="comment">func (f *File) Fd() uintptr</span></span><br><span class="line"><span class="comment">func (f *File) Name() string</span></span><br><span class="line"><span class="comment">func (f *File) Read(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">func (f *File) ReadDir(n int) ([]DirEntry, error)</span></span><br><span class="line"><span class="comment">func (f *File) ReadFrom(r io.Reader) (n int64, err error)</span></span><br><span class="line"><span class="comment">func (f *File) Readdir(n int) ([]FileInfo, error)</span></span><br><span class="line"><span class="comment">func (f *File) Readdirnames(n int) (names []string, err error)</span></span><br><span class="line"><span class="comment">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</span></span><br><span class="line"><span class="comment">func (f *File) SetDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">func (f *File) SetReadDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">func (f *File) SetWriteDeadline(t time.Time) error</span></span><br><span class="line"><span class="comment">func (f *File) Stat() (FileInfo, error)</span></span><br><span class="line"><span class="comment">func (f *File) Sync() error</span></span><br><span class="line"><span class="comment">func (f *File) SyscallConn() (syscall.RawConn, error)</span></span><br><span class="line"><span class="comment">func (f *File) Truncate(size int64) error</span></span><br><span class="line"><span class="comment">func (f *File) Write(b []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</span></span><br><span class="line"><span class="comment">func (f *File) WriteString(s string) (n int, err error)</span></span><br><span class="line"><span class="comment">type FileInfo</span></span><br><span class="line"><span class="comment">func Lstat(name string) (FileInfo, error)</span></span><br><span class="line"><span class="comment">func Stat(name string) (FileInfo, error)</span></span><br><span class="line"><span class="comment">type FileMode</span></span><br><span class="line"><span class="comment">type LinkError</span></span><br><span class="line"><span class="comment">func (e *LinkError) Error() string</span></span><br><span class="line"><span class="comment">func (e *LinkError) Unwrap() error</span></span><br><span class="line"><span class="comment">type PathError</span></span><br><span class="line"><span class="comment">type ProcAttr</span></span><br><span class="line"><span class="comment">type Process</span></span><br><span class="line"><span class="comment">func FindProcess(pid int) (*Process, error)</span></span><br><span class="line"><span class="comment">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</span></span><br><span class="line"><span class="comment">func (p *Process) Kill() error</span></span><br><span class="line"><span class="comment">func (p *Process) Release() error</span></span><br><span class="line"><span class="comment">func (p *Process) Signal(sig Signal) error</span></span><br><span class="line"><span class="comment">func (p *Process) Wait() (*ProcessState, error)</span></span><br><span class="line"><span class="comment">type ProcessState</span></span><br><span class="line"><span class="comment">func (p *ProcessState) ExitCode() int</span></span><br><span class="line"><span class="comment">func (p *ProcessState) Exited() bool</span></span><br><span class="line"><span class="comment">func (p *ProcessState) Pid() int</span></span><br><span class="line"><span class="comment">func (p *ProcessState) String() string</span></span><br><span class="line"><span class="comment">func (p *ProcessState) Success() bool</span></span><br><span class="line"><span class="comment">func (p *ProcessState) Sys() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">func (p *ProcessState) SysUsage() interface&#123;&#125;</span></span><br><span class="line"><span class="comment">func (p *ProcessState) SystemTime() time.Duration</span></span><br><span class="line"><span class="comment">func (p *ProcessState) UserTime() time.Duration</span></span><br><span class="line"><span class="comment">type Signal</span></span><br><span class="line"><span class="comment">type SyscallError</span></span><br><span class="line"><span class="comment">func (e *SyscallError) Error() string</span></span><br><span class="line"><span class="comment">func (e *SyscallError) Timeout() bool</span></span><br><span class="line"><span class="comment">func (e *SyscallError) Unwrap() error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chdir将当前工作目录更改为指定的目录，若有错，将是*PathError类型</span></span><br><span class="line"><span class="comment">    *func Chdir(dir string) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    beforeDir,_ := os.Getwd()</span><br><span class="line">    fmt.Println(beforeDir)</span><br><span class="line">    err := os.Chdir(<span class="string">&quot;sdk/test&quot;</span>)</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    latestDir,_ := os.Getwd()</span><br><span class="line">    fmt.Println(latestDir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chmod更改文件模式，若文件是符号链接将更改链接目标的模式</span></span><br><span class="line"><span class="comment">    *func Chmod(name string,mode FileMode) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err := os.Chmod(<span class="string">&quot;sdk/test.txt&quot;</span>,<span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chown 更改文件的uid（用户唯一标识符）和gid（用户组唯一标识符），若文件是符号链接则会更改链接目标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> err := os.Lchown(FilePath, <span class="number">501</span>, <span class="number">20</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chtimes 更改指定文件的访问和修改时间，类似于Unix utime()或utimes()函数</span></span><br><span class="line"><span class="comment">    *func Chtimes(name string, atime time.Time, mtime time.Time) error</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mtime := time.Date(<span class="number">2006</span>,time.February,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,time.UTC)</span><br><span class="line">    atime := time.Date(<span class="number">2007</span>,time.March,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,time.UTC)</span><br><span class="line">    <span class="keyword">if</span> err := os.Chtimes(<span class="string">&quot;some-filename&quot;</span>, atime, mtime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Clearenv 删除所有环境变量</span></span><br><span class="line"><span class="comment">    *func Clearenv()</span></span><br><span class="line"><span class="comment">        DirFS返回文件系统操作对象</span></span><br><span class="line"><span class="comment">    *func DirFS(dir string) fs.FS</span></span><br><span class="line"><span class="comment">    Executable可执行文件返回启动当前进程的可执行文件的路径名称</span></span><br><span class="line"><span class="comment">    *func Executable() (string,error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">*Expand根据映射函数替换字符串中的$&#123;var&#125;或$var。例如，os.ExpandEnv(s)</span></span><br><span class="line"><span class="comment">*等效于os.Expand(s，os.Getenv)。</span></span><br><span class="line"><span class="comment">*func Expand(s string, mapping func(string) string) string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mapper := <span class="function"><span class="keyword">func</span><span class="params">(placeholderName <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> placeholderName &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;DAY_PART&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;morning&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;NAME&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Gopher&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(os.Expand(<span class="string">&quot;Good $&#123;DAY_PART&#125;, $NAME!&quot;</span>, mapper))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ExpandEnv根据当前环境变量的值替换字符串中的$&#123;var&#125;或$var，未定义变量的引用将替换为空字符串</span></span><br><span class="line"><span class="comment">    *func ExpandEnv(s string) string</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    os.Setenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;gopher&quot;</span>)</span><br><span class="line">os.Setenv(<span class="string">&quot;BURROW&quot;</span>, <span class="string">&quot;/usr/gopher&quot;</span>)</span><br><span class="line">fmt.Println(os.ExpandEnv(<span class="string">&quot;$NAME lives in $&#123;BURROW&#125;.&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Getegid 返回调用者的数字有效组ID</span></span><br><span class="line"><span class="comment">    *func Getegid() int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Hostname返回内核提供的主机名</span></span><br><span class="line"><span class="comment">    func Hostname() (name string,err error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constants</span></span><br><span class="line"><span class="comment">func After(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">func Sleep(d Duration)</span></span><br><span class="line"><span class="comment">func Tick(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">type Duration</span></span><br><span class="line"><span class="comment">func ParseDuration(s string) (Duration, error)</span></span><br><span class="line"><span class="comment">func Since(t Time) Duration</span></span><br><span class="line"><span class="comment">func Until(t Time) Duration</span></span><br><span class="line"><span class="comment">func (d Duration) Hours() float64</span></span><br><span class="line"><span class="comment">func (d Duration) Microseconds() int64</span></span><br><span class="line"><span class="comment">func (d Duration) Milliseconds() int64</span></span><br><span class="line"><span class="comment">func (d Duration) Minutes() float64</span></span><br><span class="line"><span class="comment">func (d Duration) Nanoseconds() int64</span></span><br><span class="line"><span class="comment">func (d Duration) Round(m Duration) Duration</span></span><br><span class="line"><span class="comment">func (d Duration) Seconds() float64</span></span><br><span class="line"><span class="comment">func (d Duration) String() string</span></span><br><span class="line"><span class="comment">func (d Duration) Truncate(m Duration) Duration</span></span><br><span class="line"><span class="comment">type Location</span></span><br><span class="line"><span class="comment">func FixedZone(name string, offset int) *Location</span></span><br><span class="line"><span class="comment">func LoadLocation(name string) (*Location, error)</span></span><br><span class="line"><span class="comment">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</span></span><br><span class="line"><span class="comment">func (l *Location) String() string</span></span><br><span class="line"><span class="comment">type Month</span></span><br><span class="line"><span class="comment">func (m Month) String() string</span></span><br><span class="line"><span class="comment">type ParseError</span></span><br><span class="line"><span class="comment">func (e *ParseError) Error() string</span></span><br><span class="line"><span class="comment">type Ticker</span></span><br><span class="line"><span class="comment">func NewTicker(d Duration) *Ticker</span></span><br><span class="line"><span class="comment">func (t *Ticker) Reset(d Duration)</span></span><br><span class="line"><span class="comment">func (t *Ticker) Stop()</span></span><br><span class="line"><span class="comment">type Time</span></span><br><span class="line"><span class="comment">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</span></span><br><span class="line"><span class="comment">func Now() Time</span></span><br><span class="line"><span class="comment">func Parse(layout, value string) (Time, error)</span></span><br><span class="line"><span class="comment">func ParseInLocation(layout, value string, loc *Location) (Time, error)</span></span><br><span class="line"><span class="comment">func Unix(sec int64, nsec int64) Time</span></span><br><span class="line"><span class="comment">func (t Time) Add(d Duration) Time</span></span><br><span class="line"><span class="comment">func (t Time) AddDate(years int, months int, days int) Time</span></span><br><span class="line"><span class="comment">func (t Time) After(u Time) bool</span></span><br><span class="line"><span class="comment">func (t Time) AppendFormat(b []byte, layout string) []byte</span></span><br><span class="line"><span class="comment">func (t Time) Before(u Time) bool</span></span><br><span class="line"><span class="comment">func (t Time) Clock() (hour, min, sec int)</span></span><br><span class="line"><span class="comment">func (t Time) Date() (year int, month Month, day int)</span></span><br><span class="line"><span class="comment">func (t Time) Day() int</span></span><br><span class="line"><span class="comment">func (t Time) Equal(u Time) bool</span></span><br><span class="line"><span class="comment">func (t Time) Format(layout string) string</span></span><br><span class="line"><span class="comment">func (t *Time) GobDecode(data []byte) error</span></span><br><span class="line"><span class="comment">func (t Time) GobEncode() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (t Time) Hour() int</span></span><br><span class="line"><span class="comment">func (t Time) ISOWeek() (year, week int)</span></span><br><span class="line"><span class="comment">func (t Time) In(loc *Location) Time</span></span><br><span class="line"><span class="comment">func (t Time) IsZero() bool</span></span><br><span class="line"><span class="comment">func (t Time) Local() Time</span></span><br><span class="line"><span class="comment">func (t Time) Location() *Location</span></span><br><span class="line"><span class="comment">func (t Time) MarshalBinary() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (t Time) MarshalJSON() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (t Time) MarshalText() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (t Time) Minute() int</span></span><br><span class="line"><span class="comment">func (t Time) Month() Month</span></span><br><span class="line"><span class="comment">func (t Time) Nanosecond() int</span></span><br><span class="line"><span class="comment">func (t Time) Round(d Duration) Time</span></span><br><span class="line"><span class="comment">func (t Time) Second() int</span></span><br><span class="line"><span class="comment">func (t Time) String() string</span></span><br><span class="line"><span class="comment">func (t Time) Sub(u Time) Duration</span></span><br><span class="line"><span class="comment">func (t Time) Truncate(d Duration) Time</span></span><br><span class="line"><span class="comment">func (t Time) UTC() Time</span></span><br><span class="line"><span class="comment">func (t Time) Unix() int64</span></span><br><span class="line"><span class="comment">func (t Time) UnixNano() int64</span></span><br><span class="line"><span class="comment">func (t *Time) UnmarshalBinary(data []byte) error</span></span><br><span class="line"><span class="comment">func (t *Time) UnmarshalJSON(data []byte) error</span></span><br><span class="line"><span class="comment">func (t *Time) UnmarshalText(data []byte) error</span></span><br><span class="line"><span class="comment">func (t Time) Weekday() Weekday</span></span><br><span class="line"><span class="comment">func (t Time) Year() int</span></span><br><span class="line"><span class="comment">func (t Time) YearDay() int</span></span><br><span class="line"><span class="comment">func (t Time) Zone() (name string, offset int)</span></span><br><span class="line"><span class="comment">type Timer</span></span><br><span class="line"><span class="comment">func AfterFunc(d Duration, f func()) *Timer</span></span><br><span class="line"><span class="comment">func NewTimer(d Duration) *Timer</span></span><br><span class="line"><span class="comment">func (t *Timer) Reset(d Duration) bool</span></span><br><span class="line"><span class="comment">func (t *Timer) Stop() bool</span></span><br><span class="line"><span class="comment">type Weekday</span></span><br><span class="line"><span class="comment">func (d Weekday) String() string</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Since返回从t到现在经过的时间，等价于time.Now().Sub(t)</span></span><br><span class="line"><span class="comment">    *func Since(t Time) Duration</span></span><br><span class="line"><span class="comment">        Weekday返回由t指定的星期几</span></span><br><span class="line"><span class="comment">    *func (t Time) Weekday() Weekday</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exec（实现终端命令、脚本调用功能）"><a href="#exec（实现终端命令、脚本调用功能）" class="headerlink" title="exec（实现终端命令、脚本调用功能）"></a>exec（实现终端命令、脚本调用功能）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Variables</span></span><br><span class="line"><span class="comment">func LookPath(file string) (string, error)</span></span><br><span class="line"><span class="comment">type Cmd</span></span><br><span class="line"><span class="comment">func Command(name string, arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">func (c *Cmd) CombinedOutput() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) Output() ([]byte, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) Run() error</span></span><br><span class="line"><span class="comment">func (c *Cmd) Start() error</span></span><br><span class="line"><span class="comment">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</span></span><br><span class="line"><span class="comment">func (c *Cmd) String() string</span></span><br><span class="line"><span class="comment">func (c *Cmd) Wait() error</span></span><br><span class="line"><span class="comment">type Error</span></span><br><span class="line"><span class="comment">func (e *Error) Error() string</span></span><br><span class="line"><span class="comment">func (e *Error) Unwrap() error</span></span><br><span class="line"><span class="comment">type ExitError</span></span><br><span class="line"><span class="comment">func (e *ExitError) Error() string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Command返回Cmd结构以执行具有给定参数的命名程序</span></span><br><span class="line"><span class="comment">    *func Command(name string,arg ...string) *cmd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CommandContext类似于Command，但包含上下文，若上下文在命令本身完成之前完成，则提供的上下文用于终止进程（通过调用os.Process.Kill）</span></span><br><span class="line"><span class="comment">    *func CommandContext(ctx context.Context,name string,arg ...string) *Cmd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := exec.CommandContext(ctx, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;5&quot;</span>).Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// This will fail after 100 milliseconds. The 5 second sleep</span></span><br><span class="line"><span class="comment">// will be interrupted.</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CombinedOutput运行命令并返回其组合的标准输出和标准错误</span></span><br><span class="line"><span class="comment">    *func (c *Cmd) CombineOutput() ([]byte,error)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git笔记</title>
      <link href="/git%E7%AC%94%E8%AE%B0/"/>
      <url>/git%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Git命令用法"><a href="#Git命令用法" class="headerlink" title="Git命令用法"></a>Git命令用法</h3><h4 id="git-add和git-stash"><a href="#git-add和git-stash" class="headerlink" title="git add和git stash"></a>git add和git stash</h4><h5 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h5><p>将未提交的修改（工作区和暂存区）保存至堆栈中用于后续恢复当前工作目录，故<code>stash</code>的内容可以恢复任意分支</p><h6 id="git-stash两种应用场景"><a href="#git-stash两种应用场景" class="headerlink" title="git stash两种应用场景"></a>git stash两种应用场景</h6><ul><li><p>改动同一分支</p><p>本地修改后发现远程被改动造成冲突，此时无法<code>push</code>和<code>pull</code>，但是可以使用<code>git stash</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash save &quot;本地缓存内容标识&quot;//将本地改动暂存</span><br><span class="line">git pull//拉取远端分支</span><br><span class="line">git stash pop //将栈顶改动内容重新加回本地分支，此时可以继续修改</span><br></pre></td></tr></table></figure></li><li><p>不小心改动其它分支</p><p>当正在<code>dev</code>上开发，此时项目中出现一个bug需要紧急修复，但是正在开发的内容只完成一半还不想提交，此时可以用<code>git stash</code>将修改的内容保存至堆栈区，然后切换到<code>fixbug</code>分支进行修复；</p><p>或者本该在<code>dev</code>分支开发的内容却在<code>master</code>上进行了开发，需要重新切回<code>master</code>,用<code>git stash</code>将内容存至堆栈，切回<code>dev</code>后再次恢复内容即可，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash save &quot;本地缓存内容标识&quot;//将本地内容暂存，此时master分支恢复到上次拉取时状态</span><br><span class="line">git checkout dev//切换到需要改动的分支</span><br><span class="line">git stash pop//将改动pop到当前的分支</span><br></pre></td></tr></table></figure></li></ul><h6 id="git-stash用法"><a href="#git-stash用法" class="headerlink" title="git stash用法"></a>git stash用法</h6><ul><li><code>git stash save “save message”</code>：执行存储时，添加备注，方便查找</li><li><code>git stash list</code>：查看<code>stash</code>了哪些存储</li><li><code>git stash show</code>：显示做了哪些改动，默认show第一个存储，若要显示其它存储，后面加<code>satsh@&#123;$num&#125;</code>，比如第二个 <code>git stash show stash@&#123;1&#125;</code></li><li><code>git stash apply</code>：取出栈顶内容，不会把存储从存储列表中删除，默认第一个存储，即<code>stash@&#123;0&#125;</code>，若要使用第二个：<code>git stash apply stash@&#123;1&#125;</code></li><li><code>git stash pop</code>：取出栈顶内容并删除，默认第一个 <code>stash</code>即 <code>stash@&#123;0&#125;</code>，若要应用并删除第二个：<code>git stash pop stash@&#123;1&#125;</code>。</li><li><code>git stash drop stash@&#123;$num&#125;</code>：丢弃<code>stash@&#123;$num&#125;</code>存储，列表中删除</li><li><code>git stash clear</code>：删除所有缓存的<code>satsh</code></li></ul><h5 id="git-add和git-stash的关系"><a href="#git-add和git-stash的关系" class="headerlink" title="git add和git stash的关系"></a>git add和git stash的关系</h5><p><code>git add</code>只是将文件加到版本控制中，<code>git stash</code>能正确存储的前提是文件必须在版本控制中才行；常规<code>git stash</code>的一个限制是会暂存所有文件，有时，只想备份某些文件的方法如下：</p><ol><li>add&#96;不想备份的文件</li><li>调用<code>git stash --keep-index</code>只会备份没有被add的文件</li><li>调用<code>git reset</code>取消已经<code>add</code>的文件的备份，继续自己的工作</li></ol><h4 id="git-revert-和-git-reset-版本回退"><a href="#git-revert-和-git-reset-版本回退" class="headerlink" title="git revert 和 git reset 版本回退"></a>git revert 和 git reset 版本回退</h4><h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>创建一个新的版本，该版本内容与要回退的目标版本一致，HEAD指针指向新生成的版本，而不是目标版本</p><ul><li><code>git revert HEAD</code>撤销前一次commit</li><li><code>git revert HEAD^</code>撤销前前一次commit</li><li><code>git revert CommitVersionNum</code>撤销指定的版本</li></ul><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p>用于回退版本，可以指定退回某一次提交的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></table></figure><p><strong>–mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^            # 回退所有内容到上一个版本  </span><br><span class="line">$ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本 </span><br><span class="line">$ git  reset  052e           # 回退到指定版本</span><br></pre></td></tr></table></figure><p><strong>–soft</strong> 参数用于回退到某个版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~3   # 回退上上上一个版本 </span><br></pre></td></tr></table></figure><p><strong>–hard</strong> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~3  # 回退上上上一个版本  </span><br><span class="line">$ git reset –hard bae128  # 回退到某个版本回退点之前的所有信息。 </span><br><span class="line">$ git reset --hard origin/master    # 将本地的状态回退到和远程的一样 </span><br></pre></td></tr></table></figure><p>谨慎使用 <strong>–-hard</strong> 参数，它会删除回退点之前的所有信息</p><h5 id="git-revert和git-reset的区别"><a href="#git-revert和git-reset的区别" class="headerlink" title="git revert和git reset的区别"></a>git revert和git reset的区别</h5><ul><li><code>git revert</code>是用一次新的<code>commit</code>回滚之前的<code>commit</code>，<code>git reset</code>是直接删除指定的<code>commit</code>，操作后HEAD指针的指向不同</li><li>在回滚操作上看，效果差不多，但在日后继续<code>merge</code>以前的老版本时有区别，<code>git revert</code>是用一次逆向的<code>commit</code>“中和”，因此合并老<code>branch</code>时导致这部分改变不会再次出现，但<code>git reset</code>是把某些<code>commit</code>在某个<code>branch</code>上删除，和老<code>branch</code>再次<code>merge</code>时，这些被回滚的<code>commit</code>应该还会被引入</li></ul><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v#显示所有远程仓库</span><br><span class="line">git remote rm name#删除远程仓库</span><br><span class="line">git remote rename old_name new_name#修改仓库名</span><br></pre></td></tr></table></figure><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch#列举所有分支，与git branch --list同义</span><br><span class="line">git branch &lt;branch&gt;#创建一个名为branch的分支，不自动检出新创建的分支</span><br><span class="line">git branch -d &lt;branch&gt;#删除指定分支，当分支中有未合并的变更时，git会阻止这一次的删除操作</span><br><span class="line">git branch -D &lt;branch&gt;#强制删除指定分支，即便其中含有未合并的变更，该命令常见于当开发者希望永久删除某一开发过程中的所有commit</span><br><span class="line">git branch -m &lt;branch&gt;#将当前分支重命名为&lt;branch&gt;</span><br><span class="line">git branch -a#列举所有远程分支</span><br></pre></td></tr></table></figure><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git checkout branchname （切换到本地分支）</span><br><span class="line">git checkout -b 本地分支名 origin/远程分支名//切换远程分支（需要将远程分支与本地分支关联）</span><br><span class="line">//该命令可以将远程仓库指定的分支拉到本地，并在本地创建一个分支与指定远程仓库分支关联起来，并切换到新建的本地分支中</span><br><span class="line"></span><br><span class="line">//放弃所有工作区的修改</span><br><span class="line">git checkout .</span><br><span class="line">git checkout – filename//放弃对指定文件的修改</span><br><span class="line">git checkout -f//放弃工作区和暂存区的所有修改</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><ul><li><p>开发分支（dev）上的代码达到上线标准后，合并到master分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull </span><br><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"># merge --no-ff参数，表示Fast forward；可以保存之前的分支历史。能够更好地查看merge历史以及branch分支状态；保证版本提交、分支结构清晰</span><br><span class="line"></span><br><span class="line">git merge --no-ff dev</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当<code>master</code> 分支为保护分支时，执行<code>git push -u origin master</code>会提示远程服务器拒绝，此时需要在浏览器进行远程仓库<code>merge</code>操作</p></li><li><p>当master代码改动，需要更新开发分支（dev）上的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git pull </span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"># merge --no-ff参数，表示禁用Fast forward;可以保存之前的分支历史能够更好的查看merge历史，以及branch状态;保证版本提交、分支结构清晰</span><br><span class="line"></span><br><span class="line">git merge --no-ff  master</span><br><span class="line">git push -u origin dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="Git命令图解"><a href="#Git命令图解" class="headerlink" title="Git命令图解"></a>Git命令图解</h4><p><img src="https://img-blog.csdnimg.cn/2020010917233675.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaHE1Nzg1LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70"></p><h5 id="删除远程仓库文件及文件夹"><a href="#删除远程仓库文件及文件夹" class="headerlink" title="删除远程仓库文件及文件夹"></a>删除远程仓库文件及文件夹</h5><p>在<code>github</code>上只能删除仓库，无法删除文件夹或文件，只能通过命令解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master# 将远程仓库的项目拉下来</span><br><span class="line">$ dir# 查看有哪些文件夹</span><br><span class="line">$ git rm -r --cached .idea# 删除.idea文件夹</span><br><span class="line">$ git commit -m &#x27;删除.idea&#x27;# 提交，添加操作说明</span><br><span class="line">$ git push -u origin master# 将本次更改更新到github上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><h5 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -a # 查看所有分支：本地分支白色，当前分支绿色，远程分支红色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h5><h6 id="进入合并分支"><a href="#进入合并分支" class="headerlink" title="进入合并分支"></a>进入合并分支</h6><p><code>.git</code>同文件夹下进入<code>git bash</code>，进入要合并的分支（如develop分支合并到release，进入release目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout release # 切换分支</span><br><span class="line">git pull# 拉取最新的代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge develop# develop在上一步是白色的，不建议直接合并远程分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status# 查看是否有冲突</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h6><p>在编辑器中解决冲突后<code>git add</code>提交至暂存区，之后<code>git commit</code>提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;说点什么&quot;（-m后面的是本次提交的信息，如果不填，直接使用git commit,系统会自动生成）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push# 已提交的变动推送至远程</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="命令集"><a href="#命令集" class="headerlink" title="命令集"></a>命令集</h5><h6 id="刷新分支"><a href="#刷新分支" class="headerlink" title="刷新分支"></a>刷新分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote update origin --prune</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="查看本地分支所关联的远程分支"><a href="#查看本地分支所关联的远程分支" class="headerlink" title="查看本地分支所关联的远程分支"></a>查看本地分支所关联的远程分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="修改本地分支名称"><a href="#修改本地分支名称" class="headerlink" title="修改本地分支名称"></a>修改本地分支名称</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old_branch new_branch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="删除远程旧分支"><a href="#删除远程旧分支" class="headerlink" title="删除远程旧分支"></a>删除远程旧分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push origin :old_branch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="将新分支推送到远程仓库"><a href="#将新分支推送到远程仓库" class="headerlink" title="将新分支推送到远程仓库"></a>将新分支推送到远程仓库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin new_branch</span><br><span class="line">或者git push -u origin new_branch </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="分支切换、合并"><a href="#分支切换、合并" class="headerlink" title="分支切换、合并"></a>分支切换、合并</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/dev切换到远程dev分支</span><br><span class="line">git branch -D master develop删除本地库develop</span><br><span class="line">git checkout -b dev建立一个新的本地分支dev</span><br><span class="line">git merge origin/dev将dev与当前分支合并</span><br><span class="line">git checkout dev切换到本地dev分支</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="命令图"><a href="#命令图" class="headerlink" title="命令图"></a>命令图</h5><p><img src="https://img-blog.csdnimg.cn/f4d4bbb3de864cb882e9cf9faff30bca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATm8gU2lsdmVyIEJ1bGxldA==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="提交指定文件"><a href="#提交指定文件" class="headerlink" title="提交指定文件"></a>提交指定文件</h4><ul><li><p>应用场景：本地代码未完成需要紧急修复bug，某些开发阶段代码不想提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git status -s# 查看仓库状态</span><br><span class="line">git add 文件名# 添加需要提交的文件名</span><br><span class="line">git stash -u -k# 提交时不提交未被add的文件</span><br><span class="line">git commit -m# 提交备注信息</span><br><span class="line">git pull# 拉取合并</span><br><span class="line">git push# 推送到远程仓库</span><br><span class="line">git stash pop# 恢复之前忽略的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>当需要重命名文件时，可以使用<code>git mv [oldFileName] [new FileName]</code>，<code>Git</code>对于重命名操作分为三步进行，第一步首先重命名文件，然后再从仓库中删除原有文件，最后将新文件添加进暂存区等待提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md LOOKME.md</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add LOOKME.md</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若通过软件进行批量修改文件时，也要按照该流程先删除原文件再添加新文件</p><h4 id="查看操作历史"><a href="#查看操作历史" class="headerlink" title="查看操作历史"></a>查看操作历史</h4><p>使用<code>git log</code>打印所有参与者的提交记录</p><ul><li><p><code>-p --patch</code>显示每次提交所引入的差异，也可以限制显示条目数量，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log -p --patch -2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021072010075819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bmh1YXFpYW5nMQ==,size_16,color_FFFFFF,t_70"></p></li><li><p><code>--stat</code>：在每次提交的下面列出所有被修改的文件、有多少文件被修改了以及被修改的文件哪些行被移除或是添加了。在每次提交的最后还有一个总结</p><p><img src="https://img-blog.csdnimg.cn/20210720100637195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bmh1YXFpYW5nMQ==,size_16,color_FFFFFF,t_70"></p></li></ul><h5 id="将日志信息显示在一行上"><a href="#将日志信息显示在一行上" class="headerlink" title="将日志信息显示在一行上"></a>将日志信息显示在一行上</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="以short格式输出仓库修改信息"><a href="#以short格式输出仓库修改信息" class="headerlink" title="以short格式输出仓库修改信息"></a>以short格式输出仓库修改信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=short</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="以-full-格式输出仓库修改信息"><a href="#以-full-格式输出仓库修改信息" class="headerlink" title="以 full 格式输出仓库修改信息"></a>以 full 格式输出仓库修改信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=full</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="以-fuller-格式输出仓库修改信息"><a href="#以-fuller-格式输出仓库修改信息" class="headerlink" title="以 fuller 格式输出仓库修改信息"></a>以 fuller 格式输出仓库修改信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=fuller</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改文件与提交文件可以不是同一个人，故在查询日志时会区分修改人与提交人</p><h4 id="修改分支名称"><a href="#修改分支名称" class="headerlink" title="修改分支名称"></a>修改分支名称</h4><h5 id="修改本地分支名称-1"><a href="#修改本地分支名称-1" class="headerlink" title="修改本地分支名称"></a>修改本地分支名称</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldBranchName newBranchName</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="将本地分支的远程分支删除"><a href="#将本地分支的远程分支删除" class="headerlink" title="将本地分支的远程分支删除"></a>将本地分支的远程分支删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :oldBranchName</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="将改名后的本地分支推送到远程，并将本地分支与之关联"><a href="#将改名后的本地分支推送到远程，并将本地分支与之关联" class="headerlink" title="将改名后的本地分支推送到远程，并将本地分支与之关联"></a>将改名后的本地分支推送到远程，并将本地分支与之关联</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin newBranchName</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="文件颜色"><a href="#文件颜色" class="headerlink" title="文件颜色"></a>文件颜色</h4><ul><li>红褐色：创建之后没有<code>add</code>，没提交，不在版本控制范围内，需要先<code>add</code>文件</li><li>绿色：<code>add</code>之后文件为绿色，没有提交</li><li>蓝色：原本有一个文件，改动之后没有提交为蓝色</li></ul><h4 id="git分支管理策略"><a href="#git分支管理策略" class="headerlink" title="git分支管理策略"></a>git分支管理策略</h4><h5 id="企业项目一般分支策略"><a href="#企业项目一般分支策略" class="headerlink" title="企业项目一般分支策略"></a>企业项目一般分支策略</h5><h6 id="主分支master"><a href="#主分支master" class="headerlink" title="主分支master"></a>主分支master</h6><p>代码库应有且仅有一个主分支。所有给用户使用的正式版本都在该主分支上发布</p><h6 id="开发分支develop"><a href="#开发分支develop" class="headerlink" title="开发分支develop"></a>开发分支develop</h6><p>主分支只用于发布重大版本。日常开发应在开发分支上生成代码最新版本</p><h6 id="功能分支feature"><a href="#功能分支feature" class="headerlink" title="功能分支feature"></a>功能分支feature</h6><p>为了开发某种特定功能，从<code>develop</code>上分出来的，开发完成后再次并入，功能分支的名字，可以采用<code>feature-*</code>的形式命名</p><h6 id="预发布分支release"><a href="#预发布分支release" class="headerlink" title="预发布分支release"></a>预发布分支release</h6><p>在合并到<code>master</code>分支前，可能需要一个预发布版本进行测试，预发布分支从<code>develop上分出来</code>，预发布结束后必须合并进<code>develop</code>和<code>master</code>分支，它的命名可以采用<code>release-*</code>的形式</p><h6 id="bug分支fixbug"><a href="#bug分支fixbug" class="headerlink" title="bug分支fixbug"></a>bug分支fixbug</h6><p>该分支用于bug修补，从<code>master</code>分支上分出来，修补结束以后，再合并进<code>Master</code>和<code>Develop</code>分支，它的命名可以采用<code>fixbug-*</code>的形式</p><h6 id="其它分支other"><a href="#其它分支other" class="headerlink" title="其它分支other"></a>其它分支other</h6><h4 id="仓库文件状态"><a href="#仓库文件状态" class="headerlink" title="仓库文件状态"></a>仓库文件状态</h4><h5 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h5><p>编写代码文件、管理资源文件的区域，细分为受版本控制和不受版本控制的文件</p><h5 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h5><p>该区域和<code>index</code>文件取得了联系，实际执行<code>git add</code>的文件都生成了对应的object对象，放在<code>.git/objects</code>目录下，状态变为<code>staged</code>，当提交到版本库时，分支会引用这些对象</p><h5 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h5><p>最终的修改提交到版本库，此时提交的文件状态变成<code>committed</code>，其实也是一种<code>unmodified</code>状态，版本库会记录每一次提交，可以追溯每次修改的内容</p><p>文件状态通常可以分为：</p><ul><li>不受版本控制的<code>untracked</code>状态</li><li>受版本控制且已修改的<code>modified</code>状态</li><li>受版本控制已修改并提交到暂存区的 <code>staged</code> 状态</li><li>从暂存区已经提交到本地仓库的 <code>committed</code> 状态</li><li>提交到本地仓库未修改或者从远程仓库克隆下来的 <code>unmodified</code> 状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·Changes to be committed为暂存区已存在，需要进行提交进仓库的文件；</span><br><span class="line">·Changes not staged for commit为文件被操作尚未提交至暂存区的文件，此类文件需要使用add将其添加至缓存区再提交进仓库；</span><br><span class="line">·Untracked files为未入暂存区文件；</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status 只能查看未传送提交的次数，不能查看具体文件信息</span><br><span class="line">git cherry -v 只能查看未传送提交的描述/说明</span><br><span class="line">git log master ^origin/master 则可以查看未传送提交的详细信息</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记</title>
      <link href="/docker%E7%AC%94%E8%AE%B0/"/>
      <url>/docker%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Docker存在意义"><a href="#Docker存在意义" class="headerlink" title="Docker存在意义"></a>Docker存在意义</h3><h4 id="docker作用"><a href="#docker作用" class="headerlink" title="docker作用"></a>docker作用</h4><h5 id="虚拟机技术与容器化技术"><a href="#虚拟机技术与容器化技术" class="headerlink" title="虚拟机技术与容器化技术"></a>虚拟机技术与容器化技术</h5><ul><li>虚拟机技术<ol><li>资源占用十分多</li><li>荣誉步骤多</li><li>启动很慢</li></ol></li><li>容器化技术<ol><li>直接运行在宿主机中，容器自身无内核，也没有虚拟出硬件，所以轻便</li><li>每个容器内有自己的文件系统，互不影响</li></ol></li></ul><h5 id="DevOps（开发、运维）"><a href="#DevOps（开发、运维）" class="headerlink" title="DevOps（开发、运维）"></a>DevOps（开发、运维）</h5><ul><li><p>应用更快速的交付和部署</p><ul><li>传统：帮助文档安装程序</li><li>Docker：打包镜像发布测试一键运行</li></ul></li><li><p>更便捷的升级和扩缩容</p></li><li><p>更简单的系统运维</p><p>容器化后，开发和测试环境高度一致</p></li><li><p>更有效的计算资源利用</p></li></ul><h4 id="为什么docker比vm快"><a href="#为什么docker比vm快" class="headerlink" title="为什么docker比vm快"></a>为什么docker比vm快</h4><ol><li>docker抽象层比虚拟机少，无需Hypervisor实现硬件资源虚拟化，运行在docker上的程序使用实际物理机的硬件资源，故docker在效率上更有优势</li><li>docker利用的是宿主机的内核，而不需要Guest OS</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc?x-oss-process=image/format,png"></p><h4 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h4><h5 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h5><p>镜像相当于一个目标，通过其创建容器服务</p><h5 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h5><p>镜像创建的单个应用</p><h5 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h5><p>仓库是存放镜像的地方，仓库分为公有仓库和私有仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#1.卸载旧版本</span><br><span class="line">yum remove docker \</span><br><span class="line">                   docker-client \</span><br><span class="line">                   docker-client-latest \</span><br><span class="line">                   docker-common \</span><br><span class="line">                   docker-latest \</span><br><span class="line">                   docker-latest-logrotate \</span><br><span class="line">                   docker-logrotate \</span><br><span class="line">                   docker-engine</span><br><span class="line"></span><br><span class="line">#2.需要的安装包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">#3.设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">#更新yum软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">#4.安装docker相关的docker-ce社区版ee是企业版</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">#5.启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#6.使用docker version查看是否安装成功</span><br><span class="line">docker version </span><br><span class="line"></span><br><span class="line">#7.测试</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">#8.查看已下载的镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h4 id="docker卸载"><a href="#docker卸载" class="headerlink" title="docker卸载"></a>docker卸载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.卸载依赖</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">#2.删除资源</span><br><span class="line">yum -rf /var/lib/docker//docker默认工作路径</span><br></pre></td></tr></table></figure><h3 id="阿里镜像加速"><a href="#阿里镜像加速" class="headerlink" title="阿里镜像加速"></a>阿里镜像加速</h3><h4 id="登录阿里云找到容器镜像服务"><a href="#登录阿里云找到容器镜像服务" class="headerlink" title="登录阿里云找到容器镜像服务"></a>登录阿里云找到容器镜像服务</h4><p><img src="https://s1.ax1x.com/2023/02/03/pSsYlp8.png"></p><h4 id="找到镜像加速器"><a href="#找到镜像加速器" class="headerlink" title="找到镜像加速器"></a>找到镜像加速器</h4><p><img src="https://s1.ax1x.com/2023/02/03/pSsYMff.png"></p><h4 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1.创建一个目录</span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">#2.编写配置文件</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://t2wwyxhb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#3.重启服务</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><ol><li><p>帮助命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version#显示docker的版本信息</span><br><span class="line">docker info#显示docker系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help   #帮助命令</span><br></pre></td></tr></table></figure></li><li><p>镜像命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker images#查看所有本地主机上的镜像，可以使用docker image ls代替</span><br><span class="line">docker search#搜索镜像</span><br><span class="line">docker pull#下载镜像docker image pull</span><br><span class="line">docker rmi#删除镜像docker image rm</span><br><span class="line"></span><br><span class="line">docker search mysql --filter=STARS=3000#搜索收藏数量大于3000的mysql</span><br><span class="line"></span><br><span class="line">docker pull tomcat:8#若不写tag，默认是latest</span><br><span class="line"></span><br><span class="line">docker rmi -f 镜像id#删除指定id的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)#删除全部镜像</span><br></pre></td></tr></table></figure></li><li><p>容器命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像id#新建容器并启动</span><br><span class="line">docker ps#列出所有运行的容器</span><br><span class="line">docker rm 容器id#删除指定容器</span><br><span class="line">docker start 容器id#重启容器</span><br><span class="line">docker stop容器id#停止当前正在运行的容器</span><br><span class="line">docker kill 容器id#强制停止当前容器</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#新建容器并启动</span><br><span class="line">docker run [可选参数] image | docker container run [可选参数] image</span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;Name&quot;#容器名字 tomcat1 tomcat2用于区分容器</span><br><span class="line">-d#后台方式运行</span><br><span class="line">-it#使用交互方式运行，进入容器查看内容</span><br><span class="line">-p#指定容器的端口 -p 8080(宿主机):8080(容器)</span><br><span class="line">-P(大写)#随机指定端口</span><br><span class="line"></span><br><span class="line">#测试，启动并进入容器</span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@241b5abce65e /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@241b5abce65e /]# exit #从容器退回主机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#列出所有运行的容器</span><br><span class="line">docker ps 命令#列出当前正在运行的容器</span><br><span class="line">-a，--all#列出当前正在运行+历史运行过的容器</span><br><span class="line">-n=?，--last int#列出最近创建的?个容器</span><br><span class="line">-q，--quiet#只列出容器的编号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#退出容器</span><br><span class="line">exit#容器直接退出</span><br><span class="line">ctrl +P +Q#容器不停止退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除容器</span><br><span class="line">docker rm 容器id#删除指定容器，强制删除正在运行的容器-rf</span><br><span class="line">docker rm -f $(docker ps -aq)#删除所有的容器</span><br><span class="line">docker ps -a -q | xargs docker rm#删除所有的容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动和停止容器的操作</span><br><span class="line">docker start 容器id#启动容器</span><br><span class="line">docker restart 容器id#重启容器</span><br><span class="line">docker stop 容器id#停止当前正在运行的容器</span><br><span class="line">docker kill 容器id#强制停止当前容器</span><br></pre></td></tr></table></figure></li><li><p>其它常用命令</p><p><strong>后台启动命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID      IMAGE       COMMAND    CREATED     STATUS   PORTS    NAMES</span><br><span class="line"></span><br><span class="line">#发现centos停止了；常见的陷阱，若没有前台进程时，docker发现没有应用就会自动停止</span><br><span class="line">#nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><br></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line">#显示日志</span><br><span class="line">-tf#显示日志信息（一直更新）</span><br><span class="line">--tail number #需要显示日志条数</span><br><span class="line">docker logs -t --tail n 容器id#查看n行日志</span><br><span class="line">docker logs -ft容器id#跟着日志</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>查看容器中进程信息ps</strong></p><p><strong>查看镜像的元数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#命令docker top 容器id</span><br><span class="line">#命令docker inspect容器id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><p>docker exec -it 容器id bashshell#进入容器后开启一个新的终端，可以在里面操作（常用）</p><p>docker attach 容器id#进入容器正在执行的终端</p><p><strong>从容器拷贝到主机上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径主机目的路径</span><br><span class="line"></span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps</span><br><span class="line">CONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES</span><br><span class="line">56a5583b25b4     centos   &quot;/bin/bash&quot; 7seconds ago    Up 6 seconds      </span><br><span class="line"></span><br><span class="line">#1. 进入docker容器内部</span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash</span><br><span class="line">[root@55321bcae33d /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">#新建一个文件</span><br><span class="line">[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java</span><br><span class="line">[root@55321bcae33d /]# cat hello.java </span><br><span class="line">hello</span><br><span class="line">[root@55321bcae33d /]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">#hello.java拷贝到home文件加下</span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home </span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z /]# cd /home</span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l#可以看见java.java存在</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root    0 May 19 22:09 haust.java</span><br><span class="line">-rw-r--r-- 1 root root    6 May 22 11:12 java.java</span><br><span class="line">drwx------ 3 www  www  4096 May  8 12:14 www</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNDMxMzk2Mi5wbmc?x-oss-process=image/format,png"></p></li></ol><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>如果数据都在容器中，那么容器删除数据就会丢失；此时容器之间需要有一个数据共享的技术，Docker中产生的数据同步到本地；<strong>容器的持久化和同步操作，容器间实现数据共享</strong></p><p>卷技术：目录的挂载，将容器内的目录挂载到Linux上面</p><h4 id="方式一：直接使用命令挂载-v"><a href="#方式一：直接使用命令挂载-v" class="headerlink" title="方式一：直接使用命令挂载-v"></a>方式一：直接使用命令挂载-v</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口</span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE5MTY0Nzk3MC5wbmc?x-oss-process=image/format,png"></p><p><strong>测试文件的同步</strong>（停止容器，在宿主机中修改文件，启动容器，数据依然同步）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE5MTcxODQ3MC5wbmc?x-oss-process=image/format,png"></p><h5 id="安装MySQL挂载连接测试"><a href="#安装MySQL挂载连接测试" class="headerlink" title="安装MySQL挂载连接测试"></a>安装MySQL挂载连接测试</h5><p><strong>思考：MySQL的数据持久化的问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#获取mysql镜像</span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">#启动mysql并做数据挂载</span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 容器名字</span><br><span class="line"></span><br><span class="line">docker run -d -p 主机端口:容器内端口 -v 主机配置文件路径:/etc/mysql/conf.d -v 主机数据文件路径:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw --name 容器名字 mysql:tag</span><br><span class="line"></span><br><span class="line">#此时在本地新建数据库时，容器也会创建对应的数据库；若将容器内mysql删除，挂载到本地的数据卷依旧没有丢失，实现了容器数据持久化功能</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 匿名挂载（在-v中只写了容器内的路径，没有写容器外的路径）</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"># 查看所有的volume(卷)的情况</span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)</span><br><span class="line">local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0</span><br><span class="line">local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c</span><br><span class="line"></span><br><span class="line"># 具名挂载 -P:表示随机映射端口</span><br><span class="line">docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line"># 查看所有的volume(卷)的情况</span><br><span class="line">$ docker volume ls                  </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0</span><br><span class="line">local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c</span><br><span class="line">local               juming-nginx #多了一个名字</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有的docker容器内的卷，未指定目录时都是在**&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;自定义的卷名&#x2F;_data**下</p><p><strong>如果指定了目录，docker volume ls 是查看不到的</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjExNDIzMTQzNS5wbmc?x-oss-process=image/format,png"></p><h4 id="区分三种挂载方式"><a href="#区分三种挂载方式" class="headerlink" title="区分三种挂载方式"></a>区分三种挂载方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span><br><span class="line">-v 容器内路径#匿名挂载</span><br><span class="line">-v 卷名：容器内路径  #具名挂载</span><br><span class="line">-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 通过 -v 容器内路径： ro rw 改变读写权限</span><br><span class="line">ro #readonly 只读rw #readwrite 可读可写</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"># ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong></p><p>镜像是一层一层的，脚本是一个个的命令，每个命令都是一层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 文件中的内容： 指令(大写) + 参数</span><br><span class="line">$ vim dockerfile1</span><br><span class="line">    FROM centos # 当前镜像是以centos为基础的</span><br><span class="line"></span><br><span class="line">    VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] # 挂载卷的卷目录列表(多个目录)</span><br><span class="line"></span><br><span class="line">    CMD echo &quot;-----end-----&quot;# 输出一下用于测试</span><br><span class="line">    CMD /bin/bash# 默认走bash控制台</span><br><span class="line">    </span><br><span class="line">$ docker build -f dockerfile1 -t dockerfiletest/centos .</span><br><span class="line"># -f 代表当前文件的地址（这里是当前目录下的dockerfile1）</span><br><span class="line"># -t 代表target，指目标目录（dockerfiletest镜像名前不能加斜杠&#x27;/&#x27;）</span><br><span class="line"># .表示生成在当前目录下</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="容器间的数据同步"><a href="#容器间的数据同步" class="headerlink" title="容器间的数据同步"></a>容器间的数据同步</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建docker01</span><br><span class="line">docker run -it --name docker01 dockerfiletest/centos</span><br><span class="line"># 查看docker01的内容</span><br><span class="line">ls</span><br><span class="line">bin  home   lost+foundopt   run   sys  var</span><br><span class="line">dev  lib    mediaproc  sbin  tmp  volume01</span><br><span class="line">etc  lib64  mntroot  srv   usr  volume02</span><br><span class="line"># 不关闭该容器退出</span><br><span class="line">ctrl + Q + P</span><br><span class="line"></span><br><span class="line"># 创建docker02：并让docker02继承docker01</span><br><span class="line">docker run -it --name docker02 --volumes-from docker01 dockerfiletest/centos</span><br><span class="line"># 查看docker02内容</span><br><span class="line">ls</span><br><span class="line">bin  home   lost+foundopt   run   sys  var</span><br><span class="line">dev  lib    mediaproc  sbin  tmp  volume01</span><br><span class="line">etc  lib64  mntroot  srv   usr  volume02</span><br><span class="line"></span><br><span class="line">#在docker01的volume01下创建docker01.txt；在docker02中查看文件已同步</span><br><span class="line"></span><br><span class="line"># 新建一个docker03同样继承docker01，发现volume01卷下也有docker01.txt</span><br><span class="line">docker run -it --name docker03 --volumes-from docker01 dockerfiletest/centos</span><br><span class="line"></span><br><span class="line"># 删除docker01，发现docker02和docker03中没有删除</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现多个mysql的数据共享"><a href="#实现多个mysql的数据共享" class="headerlink" title="实现多个mysql的数据共享"></a>实现多个mysql的数据共享</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root --name mysql02 --volumes-from mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line"># 这个时候可以实现两个容器数据同步</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止；一旦持久化到了本地，此时本地的数据是不会删除的</strong></p><h4 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h4><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><ol><li>每个保留关键字（指令）都必须是大写字母</li><li>执行顺序从上到下</li><li>#表示注释</li><li>每个指令都会创建提交一个新的镜像层，并提交</li></ol><h5 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM#from：基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER#maintainer：镜像作者，姓名+邮箱</span><br><span class="line">RUN#run：镜像构建时需要运行的命令</span><br><span class="line">ADD#add：步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span><br><span class="line">WORKDIR#workdir：镜像的工作目录</span><br><span class="line">VOLUME#volume：挂载的目录</span><br><span class="line">EXPOSE#expose：保留端口配置</span><br><span class="line">CMD#cmd：指定该容器启动时要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT#entrypoint：指定容器启动时运行命令，可以追加命令</span><br><span class="line">ONBUILD#onbuild：构建被继承DockerFile时运行onbuild</span><br><span class="line">COPY#copy：类似ADD，将文件拷贝到镜像中</span><br><span class="line">ENV#env：构建时设置环境变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/02/03/pSsY11S.png"></p><h5 id="镜像发布"><a href="#镜像发布" class="headerlink" title="镜像发布"></a>镜像发布</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE3MTE1NTY2Ny5wbmc?x-oss-process=image/format,png"></p><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><h4 id="理解Docker-0"><a href="#理解Docker-0" class="headerlink" title="理解Docker 0"></a>理解Docker 0</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTIyMzIzNjc3Mi5wbmc?x-oss-process=image/format,png"></p><h4 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h4><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息，其会创建一个父子关系，父容器可以看到子容器的信息</p><h5 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a>容器创建</h5><p><code>docker run -d -P --name coonote training/webapp python app.py</code></p><h5 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h5><p><code>docker network create -d bridge test-net</code></p><p><img src="https://s1.ax1x.com/2023/03/20/ppNM5Hf.png"></p><h5 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h5><p>运行一个容器并连接到新建的 test-net 网络</p><p><code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code></p><p>再运行一个容器并加入到 test-net 网络</p><p><code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></p><p><img src="https://s1.ax1x.com/2023/03/20/ppNMTUS.png"></p><h5 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt install iputils-ping</span><br><span class="line"><span class="comment">#在 test1 容器输入以下命令</span></span><br><span class="line">ping test2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h5><p>可以在宿主机的<code>/etc/docker/daemon.json</code>文件中增加以下内容来设置全部容器的 DNS：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置完后重启docker才生效，查看容器的DNS信息：</p><p><code>/etc/init.d/docker restart</code></p><p><code>docker run -it --rm ubuntu cat etc/resolv.conf</code></p><h6 id="手动指定容器的配置"><a href="#手动指定容器的配置" class="headerlink" title="手动指定容器的配置"></a>手动指定容器的配置</h6><p><code>docker run -it --rm -h host_ubuntu  --dns=114.114.114.114 --dns-search=test.com ubuntu</code></p><ul><li><code>--rm</code>：容器退出时自动清理内部的文件系统</li><li><code>-h 或 --hostname</code>：设定容器主机名，会被写到容器内的<code>/etc/hostname</code>和<code>/etc/hosts</code></li><li><code>--dns</code>：添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code>中的主机名</li><li><code>--dns-search</code>：设定容器搜索域，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com</li></ul><p>若容器启动时未指定 <strong>–dns</strong> 和 <strong>–dns-search</strong>，会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的 DNS</p><h4 id="Docker网络实现"><a href="#Docker网络实现" class="headerlink" title="Docker网络实现"></a>Docker网络实现</h4><p>在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通</p><h5 id="创建网络参数"><a href="#创建网络参数" class="headerlink" title="创建网络参数"></a>创建网络参数</h5><p>Docker创建一个容器时执行的操作：</p><ul><li>创建一对虚拟接口，分别放在本地主机和新容器中</li><li>本地主机一端桥接到默认的docker0或指定网桥上，并具有一个唯一的名字</li><li>容器一端放到新容器中并修改名字为eth0，该接口只在容器的名字空间可见</li><li>从网桥可用地址段中获取一个空闲地址分配给容器的eth0，并配置默认路由到桥接网卡</li></ul><p>完成这些之后，容器就可以使用eth0虚拟网卡连接其他容器和其他网络</p><p>也可以在<code>docker run</code>时通过<code>--net</code>指定容器的网络配置：</p><ul><li><code>--net=bridge</code>：默认值，连接到默认的网桥</li><li><code>--net=host</code>：不将容器网络放到隔离的<code>namespace</code>中，此时容器使用本地主机的网络，若进一步使用<code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈</li><li><code>--net=container:NAME_or_ID</code>：将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享IP地址和端口等网络资源，两者进程可以直接通过 lo环回接口通信</li><li><code>--net=none</code>：将新容器放到隔离的网络栈中，但是不进行网络配置，之后由用户自己配置</li></ul><h5 id="网络配置细节"><a href="#网络配置细节" class="headerlink" title="网络配置细节"></a>网络配置细节</h5><p>首先启动一个 &#x2F;bin&#x2F;bash 容器，指定 –net&#x3D;none 参数</p><p><code>sudo docker run -i -t --rm --net=none base /bin/bash</code></p><p>在本地主机查找容器进程id，并为它创建网络命名空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 63f36fc01b5f</span><br><span class="line">2778</span><br><span class="line">$ pid=2778</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ sudo <span class="built_in">ln</span> -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查桥接网卡的IP和子网掩码信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show docker0</span><br><span class="line">21: docker0: ...</span><br><span class="line">inet 172.17.42.1/16 scope global docker0</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 docker0，并启用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line">$ sudo brctl addif docker0 A</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 172.17.42.99/16 dev eth0</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip route add default via 172.17.42.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h3><p>即可供一个或多个容器使用的特殊目录，绕过UFS（UNIX文件系统），可提供：</p><ul><li><code>数据卷</code>在容器间的共享和重用</li><li>对<code>数据卷</code>的修改会立马生效</li><li>对<code>数据卷</code>的更新不会影响镜像</li><li><code>数据卷</code>默认一直存在，即使容器被删除</li></ul><blockquote><p>数据卷的使用类似Linux下对目录或文件进行mount，镜像中被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）</p></blockquote><h4 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h4><p><code>docker volume create my-vol</code></p><h4 id="查看数据卷"><a href="#查看数据卷" class="headerlink" title="查看数据卷"></a>查看数据卷</h4><p><code>docker volume inspect my-vol</code></p><h4 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h4><p><code>docker run -d -P --name web -v my-vol:/usr/share/nginx/html nginx</code></p><p><code>docker inspect web</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">              &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">              &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">              &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">              &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">              &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">              &quot;RW&quot;: true,</span><br><span class="line">              &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p><code>docker volume rm my-vol</code></p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>实现对docker容器集群的快速编排，允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件定义一组相关联的应用容器为一个项目</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义</li></ul><p><code>Compose</code> 默认管理对象是项目，通过子命令对项目中一组容器进行生命周期管理</p><h4 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h4><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="window"><a href="#window" class="headerlink" title="window"></a>window</h5><p>可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行</p><h5 id="bash命令补全"><a href="#bash命令补全" class="headerlink" title="bash命令补全"></a>bash命令补全</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><p>若是二进制包安装的，删除二进制文件即可</p><p><code>rm /usr/local/bin/docker-compose </code></p><h5 id="测试安装成功"><a href="#测试安装成功" class="headerlink" title="测试安装成功"></a>测试安装成功</h5><p><code>docker-compose --version</code></p><h4 id="docker-compose使用"><a href="#docker-compose使用" class="headerlink" title="docker compose使用"></a>docker compose使用</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysqldb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.19</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/logs:/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:4.0.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/data:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">ems:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>docker-compose up</code>：前台启动一组服务</p><p>每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置</p><ul><li><p><code>build</code>：指定<code>dockerfile</code>所在文件夹的路径；也可使用<code>context</code>指定路径，使用<code>dockerfile</code>指定<code>dockerfile</code>文件名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span> <span class="string">./dir</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>command</code>：覆盖容器启动后默认执行的命令</p></li><li><p><code>container_name</code>：指定容器名称，默认使用<code>项目名称_服务名称_序号</code>格式</p></li><li><p><code>depends_on</code>：解决容器的依赖、启动先后问题，下列例子会先启动<code>redis db</code>再启动<code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#web服务不会等待redis db完全启动后才启动</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>env_file</code>：从文件中获取环境变量，如果有变量名称与 <code>environment</code> 指令冲突，以后者为准</p></li><li><p><code>environment</code> ：设置环境变量，可以使用数组或字典格式；只给定名称的变量会自动获取运行compose主机上对应变量的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>healthcheck</code>：通过命令检查容器是否健康运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>image</code>：指定为镜像名称或镜像 ID，若在本地不存在将会尝试拉取这个镜像</p></li><li><p><code>networks</code>：配置容器连接的网络</p></li><li><p><code>ports</code>：暴露端口信息，使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）</p><blockquote><p>当使用 HOST:CONTAINER 格式来映射端口时，若使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式</p></blockquote></li><li><p><code>sysctls</code>：配置容器内核参数</p></li><li><p><code>ulimits</code>：指定容器的限制值</p></li><li><p><code>volumes</code>：数据卷挂载路径设置，可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）</p><blockquote><p>若路径为数据卷名称，必须在文件中配置数据卷</p></blockquote></li></ul><h4 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker compose常用命令"></a>docker compose常用命令</h4><p><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></p><h5 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h5><ul><li><code>-f，--file FILE</code>：指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定</li><li><code>-p，--project-name NAME</code>：指定项目名称，默认使用所在目录名称作为项目名</li><li><code>--x-networking</code>：使用docker的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code>：指定网络后端的驱动，默认为<code>bridge</code></li><li><code>--verbose</code>：输出更多调试信息</li><li><code>-v --version</code>：打印版本并退出</li></ul><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><ul><li><p><code>up</code>：<code>docker-compose up [options] [SERVICE...]</code></p><p>它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作</p><p>链接的服务都将会被自动启动，除非已经处于运行状态</p><p>默认情况启动的容器都在前台</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项</p><p>默认情况下如果服务容器已经存在，将会尝试停止容器，然后重新创建，以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p></li><li><p><code>down</code>：停止<code>up</code>启动的容器，并移除网络</p></li><li><p><code>exec</code>：进入指定的容器</p></li><li><p><code>ps</code>：列出项目中目前所有的容器</p><p><code>-q</code>：只打印容器的ID信息</p></li><li><p><code>restart</code>：重启项目中的服务</p><p><code>-t</code>：指定重启前停止容器的超时</p></li><li><p><code>rm</code>：删除所有（停止状态的）服务容器</p><p><code>-f，--force</code>：强制删除</p><p><code>-v</code>：删除容器挂载的数据卷</p></li><li><p><code>start</code>：启动已存在的服务容器</p></li><li><p><code>stop</code>：停止已经处于运行状态的容器</p><p><code>-t，--timeout TIMEOUT</code>：停止容器时候的超时（默认为 10 秒）</p></li><li><p><code>top</code>：查看各个服务容器内运行的进程</p></li><li><p><code>unpause</code>：恢复处于暂停状态中的服务</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="连接docker中的mysql"><a href="#连接docker中的mysql" class="headerlink" title="连接docker中的mysql"></a>连接docker中的mysql</h3><h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="Docker下载mysql"><a href="#Docker下载mysql" class="headerlink" title="Docker下载mysql"></a>Docker下载mysql</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启动mysql实例"><a href="#启动mysql实例" class="headerlink" title="启动mysql实例"></a>启动mysql实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 13306:3306 -v /usr/local/mysql/conf:/etc/mysql/conf.d </span><br><span class="line">-v /usr/local/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name  mysql mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --name为mysql的实例设置别名-p 13306对外暴露的端口，3306内部端口</span><br><span class="line"># -e MYSQL_ROOT_PASSWORD 初始化设置mysql登录密码 -d 表示后台运行</span><br><span class="line"># 最后的mysql是镜像名称-v为挂载（etc为配置文件，log为日志文件，lib为配置文件，将mysql容器内部文件挂载到linux中，每次变动都会在linux显示，而不用进入到容器内部查看）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="进入容器内部-mysql为容器名字"><a href="#进入容器内部-mysql为容器名字" class="headerlink" title="进入容器内部(mysql为容器名字)"></a>进入容器内部(mysql为容器名字)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="创建用户授予权限"><a href="#创建用户授予权限" class="headerlink" title="创建用户授予权限"></a>创建用户授予权限</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant all on *.* to root@&#x27;%&#x27;;</span><br><span class="line">flush privileges;#刷新权限</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service#开启防火墙</span><br><span class="line">firewall-cmd --list-ports#查看开启的端口号</span><br><span class="line">firewall-cmd --zone=public --add-port=13306/tcp --permanent</span><br><span class="line">#永久开启一个端口号</span><br><span class="line">firewall-cmd --reload#重启防火墙</span><br><span class="line">firewall-cmd --list-ports#再次查看端口号是否开启</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="本地可以使用docker地址加暴露ip连接mysql"><a href="#本地可以使用docker地址加暴露ip连接mysql" class="headerlink" title="本地可以使用docker地址加暴露ip连接mysql"></a>本地可以使用docker地址加暴露ip连接mysql</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr#查看虚拟机ip地址，使用工具连接ip加端口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="docker启动mysql失败"><a href="#docker启动mysql失败" class="headerlink" title="docker启动mysql失败"></a>docker启动mysql失败</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ecs-kc1-small-1-linux:~# docker run -p 3306:3306 mysql:8-oracle</span><br><span class="line">2022-03-05 13:40:49+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.28-1.el8 started.</span><br><span class="line">2022-03-05 13:40:50+00:00 [Note] [Entrypoint]: Switching to dedicated user &#x27;mysql&#x27;</span><br><span class="line">2022-03-05 13:40:50+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.28-1.el8 started.</span><br><span class="line">2022-03-05 13:40:50+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified</span><br><span class="line">    You need to specify one of the following:</span><br><span class="line">    - MYSQL_ROOT_PASSWORD</span><br><span class="line">    - MYSQL_ALLOW_EMPTY_PASSWORD</span><br><span class="line">    - MYSQL_RANDOM_ROOT_PASSWORD</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>此问题的原因是启动命令中缺少密码，由于使用的是Linux的root用户，因此将启动命令修改为如下所示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -d -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="连接docker中的elasticsearch7-6-2"><a href="#连接docker中的elasticsearch7-6-2" class="headerlink" title="连接docker中的elasticsearch7.6.2"></a>连接docker中的elasticsearch7.6.2</h3><h4 id="主要步骤-1"><a href="#主要步骤-1" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="docker下载相关镜像"><a href="#docker下载相关镜像" class="headerlink" title="docker下载相关镜像"></a>docker下载相关镜像</h5><p><code>docker pull elasticsearch:7.6.2</code></p><h5 id="创建持久化文件"><a href="#创建持久化文件" class="headerlink" title="创建持久化文件"></a>创建持久化文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h5><p><code>echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</code></p><h5 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms84m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"># -p:端口映射</span><br><span class="line"># -e discovery.type=single-node 单点模式启动</span><br><span class="line"># -e ES_JAVA_OPTS=&quot;-Xms84m -Xmx512m&quot;：设置启动占用的内存范围（实验环境启动后可能因为云服务器内存过小而占满）</span><br><span class="line"># -v 目录挂载</span><br><span class="line"># -d 后台运行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="安装kibana"><a href="#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h5><h6 id="下载同版本镜像"><a href="#下载同版本镜像" class="headerlink" title="下载同版本镜像"></a>下载同版本镜像</h6><p><code>docker pull kibana:7.6.2</code></p><h6 id="初始化配置-1"><a href="#初始化配置-1" class="headerlink" title="初始化配置"></a>初始化配置</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/kibana</span><br><span class="line">touch /mydata/kibana/kibana.yml</span><br><span class="line">vim /mydata/kibana/kibana.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> <span class="string">http://你的ip:9200</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="启动kibana"><a href="#启动kibana" class="headerlink" title="启动kibana"></a>启动kibana</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -v /mydata/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml -p 5601:5601 -d kibana:7.6.2 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="文件权限问题"><a href="#文件权限问题" class="headerlink" title="文件权限问题"></a>文件权限问题</h5><p>elasticsearch启动后使用docker ps查看发现未正常启动，查看启动日志</p><p><code>docker logs elasticsearch</code></p><p><img src="https://s1.ax1x.com/2023/02/17/pSqCzhn.png"></p><p>发现是文件拒绝访问异常,为该文件夹设置所有用户都有读写执行权限</p><p><code>chmod -R 777 /mydata/elasticsearch/</code></p><p>重新启动elasticsearch</p><p><code>docker restart elasticsearch</code></p><h5 id="jdk版本过低"><a href="#jdk版本过低" class="headerlink" title="jdk版本过低"></a>jdk版本过低</h5><p>启动日志中也有可能报以下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是jdk版本过低，需要将jdk升级到9.0以上；去镜像网站下载jdk(这里是去华为云下载的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line">wget https://repo.huaweicloud.com/java/jdk/9.0.1+11/jdk-9.0.1_linux-x64_bin.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf jdk-9.0.1_linux-x64_bin.tar.gz </span><br><span class="line"></span><br><span class="line"># 配置JAVA_HOME</span><br><span class="line">vim /etc/profile</span><br><span class="line"># 内容如下</span><br><span class="line">export JAVA_HOME=/usr/local/jdk-9.0.1</span><br><span class="line">export JRE_HOME=/usr/local/jdk-9.0.1/jre</span><br><span class="line">export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line"></span><br><span class="line"># 删除原jdk环境</span><br><span class="line"># 此时执行java-version可能显示的还是jdk1.8</span><br><span class="line"># 执行which java，会输出一个目录，删除之</span><br><span class="line"># 执行which javac，也会输出一个目录，删除之</span><br><span class="line"># 执行 ln -s $JAVA_HOME/bin/java /usr/bin/java</span><br><span class="line"># 执行 ln -s $JAVA_HOME/bin/javac /usr/bin/javac</span><br><span class="line"># 执行 source /etc/profile再次查看java版本即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="连接docker中的redis"><a href="#连接docker中的redis" class="headerlink" title="连接docker中的redis"></a>连接docker中的redis</h3><h4 id="主要步骤-2"><a href="#主要步骤-2" class="headerlink" title="主要步骤"></a>主要步骤</h4><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><p><code>docker pull redis</code></p><h5 id="挂载配置文件"><a href="#挂载配置文件" class="headerlink" title="挂载配置文件"></a>挂载配置文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/redis/myredis</span><br><span class="line">cd /home/redis/myredis</span><br><span class="line">mkdir data</span><br><span class="line">vim redis.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"># redis.conf</span><br><span class="line"></span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">requirepass 123456#设置密码</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize no</span><br><span class="line">supervised no</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line">databases 30</span><br><span class="line">always-show-logo yes</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir ./</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line">replica-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">replica-priority 100</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line">appendonly yes#开启redis持久化</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line">activerehashing yes</span><br><span class="line">hz 10</span><br><span class="line">dynamic-hz yes</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="启动redis容器"><a href="#启动redis容器" class="headerlink" title="启动redis容器"></a>启动redis容器</h5><p><code>docker run --restart=always --log-opt max-file=2 -p 6379:6379 --name myredis -v /home/redis/myredis/myredis.conf:/etc/redis/redis.conf -v /home/redis/myredis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass 123456 </code></p><h5 id="进入容器内部测试"><a href="#进入容器内部测试" class="headerlink" title="进入容器内部测试"></a>进入容器内部测试</h5><p><code>docker exec -it myredis redis-cli</code></p><p><code>auth 123456</code></p><p><code>ping</code></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>在启动redis时不要修改防火墙，可能会出现报错</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7z工具安装及使用</title>
      <link href="/7z%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/7z%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由于windows加密算法与linux不同，导致使用<code>unzip</code>解压windows中加密的压缩文件可能报错，推荐使用<code>7-zip</code></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>yum install p7zip -y</code></p><p>可能会出现没有可用的软件包的问题</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>更新epel第三方软件库</p><blockquote><p>卸载：yum remove epel-release</p><p>清空目录：rm -rf &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;6&#x2F;epel&#x2F;</p><p>安装：yum install  epel-release</p></blockquote><p>重新安装</p><p><code>yum install p7zip -y </code></p><blockquote><p>注：该安装包安装完后有7za程序，支持zip格式，不支持rar等格式</p><p>若要支持其它格式则安装p7zip-full，安装完成后有7z（全功能）、7za（仅适用7zip本身）、7zr（只支持7z格式）三个程序</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>7z [adeltux] [-][SWITCH] …</code></p><ul><li>第一个参数[adeltux]表示执行的功能<ul><li><code>a</code>：创建压缩文件或向压缩文件中添加文件</li><li><code>d</code>：从压缩文件里删除文件</li><li><code>e</code>：解压，但不创建目录结构</li><li><code>l</code>：显示压缩文件中包含的内容</li><li><code>t</code>：测试压缩文件是否有效</li><li><code>u</code>：更新压缩文件中的文件</li><li><code>x</code>：解压，创建目录结构</li></ul></li><li>[-][SWITCH]表示对应的选项<ul><li><code>-t</code>：指定压缩格式</li><li><code>-p</code>：设置密码，如<code>-p123456</code></li><li><code>-o</code>：指定解压后的存放目录</li></ul></li></ul><p>最后接对应的压缩文件名(可以使用通配符，可以有多个文件)</p><p>7-zip退出后也有自己的返回值，在命令执行完成后马上执行echo $?命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0正常</span><br><span class="line">1警告（无错误），某些文件在压缩过程中无法读取</span><br><span class="line">2错误</span><br><span class="line">7无法识别命令行参数</span><br><span class="line">8没有足够的内存执行操作</span><br><span class="line">255用户自行按下Ctrl+C来中止程序</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
